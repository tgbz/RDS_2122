{
    "sourceFile": "TP2/multipath.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1655640459039,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1655640459039,
            "name": "Commit-0",
            "content": "# https://github.com/al13mi/multipath-1/blob/master/ryu_multipath.py\n# sudo rm ./sdn/ryu-controller/ah_learn_ryu_00/ryu_multipath.py && sudo vim  ./sdn/ryu-controller/ah_learn_ryu_00/ryu_multipath.py\n# clear && ryu-manager ./sdn/ryu-controller/ah_learn_ryu_00/ryu_multipath.py --observe-links --ofp-tcp-listen-port 6633\n# clear && sudo ryu-manager ryu_mulipath.py ../../flowmanager/flowmanager.py  ryu.app.ofctl_rest --observe-links --ofp-tcp-listen-port 6633\n\n\n\n#http://192.168.1.8:8080/home/topology.html\n#sudo ovs-ofctl -O openflow13 dump-flows s1\n#sudo ovs-ofctl -O openflow13 dump-groups s1\n\nfrom ryu.base import app_manager\nfrom ryu.controller import mac_to_port\nfrom ryu.controller import ofp_event\nfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\nfrom ryu.controller.handler import set_ev_cls\nfrom ryu.ofproto import ofproto_v1_3\nfrom ryu.lib.mac import haddr_to_bin\nfrom ryu.lib.packet import packet\nfrom ryu.lib.packet import arp\nfrom ryu.lib.packet import ethernet\nfrom ryu.lib.packet import ipv4\nfrom ryu.lib.packet import ipv6\nfrom ryu.lib.packet import ether_types\nfrom ryu.lib import mac, ip\nfrom ryu.topology.api import get_switch, get_link\nfrom ryu.app.wsgi import ControllerBase\nfrom ryu.topology import event\n\nfrom collections import defaultdict\nfrom operator import itemgetter\n\nimport os\nimport random\nimport time\n\n# Cisco Reference bandwidth = 1 Gbps\nREFERENCE_BW = 10000000\n\nDEFAULT_BW = 10000000\n\nMAX_PATHS = float('Inf')\n\nidle_time=30\n\nclass ProjectController(app_manager.RyuApp):\n    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n\n    def __init__(self, *args, **kwargs):\n        super(ProjectController, self).__init__(*args, **kwargs)\n        self.mac_to_port = {}\n        self.topology_api_app = self\n        self.datapath_list = {}\n        self.arp_table = {}\n        self.switches = []\n        self.hosts = {}\n        self.multipath_group_ids = {}\n        self.group_ids = []\n        self.adjacency = defaultdict(dict)\n        self.bandwidths = defaultdict(lambda: defaultdict(lambda: DEFAULT_BW))\n        self.en_clear_flow_entry = False\n        self.disable_packet_in = False\n        self.input_port=0\n\n    def get_paths(self, src, dst):\n        '''\n        Get all paths from src to dst using DFS algorithm    \n        '''\n        if src == dst:\n            # host target is on the same switch\n            return [[src]]\n        paths = []\n        stack = [(src, [src])]\n        #print(\"self.adjacency \", self.adjacency)\n        \n        while stack:\n            #print(\"get_pahs; stack = \",stack)\n            (node, path) = stack.pop()\n            #print( \"(node, path), node = \",node, \" path = \",path)\n            \n            for next in set(self.adjacency[node].keys()) - set(path):\n                if next is dst:\n                    paths.append(path + [next])\n                else:\n                    stack.append((next, path + [next]))\n        #print(\"stack after while is \", stack)\n        print (\"Available paths from src_switch\", src, \" to dst_switch\", dst, \" : \", paths)\n        return paths\n\n    def get_link_cost(self, s1, s2):\n        '''\n        Get the link cost between two switches \n        '''\n        e1 = self.adjacency[s1][s2]\n        e2 = self.adjacency[s2][s1]\n        bl = min(self.bandwidths[s1][e1], self.bandwidths[s2][e2])\n        ew = REFERENCE_BW/bl\n        return ew\n\n    def get_path_cost(self, path):\n        '''\n        Get the path cost\n        '''\n        cost = 0\n        for i in range(len(path) - 1):\n            cost += self.get_link_cost(path[i], path[i+1])\n        return cost\n       #get_optimal_paths(src_switch, dst_switch)\n    def get_optimal_paths(self, src, dst): #src is switch, dst is switch\n        '''\n        Get the n-most optimal paths according to MAX_PATHS\n        '''\n        paths = self.get_paths(src, dst)\n        paths_count = len(paths) if len(\n            paths) < MAX_PATHS else MAX_PATHS\n        return sorted(paths, key=lambda x: self.get_path_cost(x))[0:(paths_count)]\n\n    def add_ports_to_paths(self, paths, first_port, last_port):\n        '''\n        Add the ports that connects the switches for all paths\n        '''\n        paths_p = []\n        for path in paths:\n            p = {}\n            in_port = first_port\n            for s1, s2 in zip(path[:-1], path[1:]):\n                out_port = self.adjacency[s1][s2]\n                p[s1] = (in_port, out_port)\n                in_port = self.adjacency[s2][s1]\n            p[path[-1]] = (in_port, last_port)\n            paths_p.append(p)\n        return paths_p\n\n    def generate_openflow_gid(self):\n        '''\n        Returns a random OpenFlow group id\n        '''\n        n = random.randint(0, 2**32)\n        while n in self.group_ids:\n            n = random.randint(0, 2**32)\n        return n\n\n  #self.install_paths(      h1[0],       h1[1],      h2[0],       h2[1],   src_ip, dst_ip)\n    def install_paths(self, src_switch, first_port, dst_switch, last_port, ip_src, ip_dst):\n        computation_start = time.time()\n        paths = self.get_optimal_paths(src_switch, dst_switch)\n        print(\"paths from src_switch  \",src_switch, \" to dst_switch  \",dst_switch, \" are \",paths)\n        pw = []\n        for path in paths:\n            pw.append(self.get_path_cost(path))\n            print (path, \"cost = \", pw[len(pw) - 1])\n        sum_of_pw = sum(pw)\n        paths_with_ports = self.add_ports_to_paths(paths, first_port, last_port)\n        switches_in_paths = set().union(*paths)\n        #print(\"switches_in_paths is \", switches_in_paths)\n        print(\"Example for paths_with_ports [{1: (1, 2), 2: (1, 3)}, {1: (1, 3), 4: (1, 3), 3: (1, 3), 2: (2, 3)}] \\n\" ,\n        \"host path is from s1 port 1 to port 2 then you are now at s2 use port 1 to port 3 to connect to dest host\")\n        print(\" paths_with_ports is \", paths_with_ports)\n        single_path=paths_with_ports[0]\n        print(\" Single path from src switch to dst switch is \", single_path)\n        key_val= [key_val for key_val in single_path.keys()]\n        print(\"****************************key_val of single path is \",key_val)\n        \n        for j in range(len(key_val) ):\n            print(\"at j = \" ,j ,\" key_val = \",key_val[j])\n            print(\"single_path   \", single_path[key_val[j]][0])\n            \n        \n        print(\"ip_src  = \",ip_src, \" ip_dst = \",ip_dst)\n        for j in range(len(key_val) ):\n            print(\"src_sw_dp = \",key_val[j])\n            if(j== len(key_val)-1):\n                #last switch in path\n                print(\"self.adjacency = \",self.adjacency)\n                src_sw_dp = self.datapath_list[key_val[j]]\n                mac= self.arp_table[ip_src]\n\n                #print(\"src host is connected to port \", self.hosts[mac][key_val[len(key_val)-1]], \" src_sw_dp = \",key_val[j])\n                final_out = single_path[key_val[len(key_val)-1]][1]  #self.hosts[mac][key_val[len(key_val)-1]]\n                print(\"Last switch in the loop port number is \",final_out)\n                src_sw_dp = self.datapath_list[key_val[j]]\n                print(\"Packet is recevied from port  \",self.input_port)\n                ofp = src_sw_dp.ofproto\n                ofp_parser = src_sw_dp.ofproto_parser\n                match_ip = ofp_parser.OFPMatch(\n                        eth_type=0x0800, \n                        ipv4_src=ip_src, \n                        ipv4_dst=ip_dst\n                    )\n                match_arp = ofp_parser.OFPMatch(\n                        eth_type=0x0806, \n                        arp_spa=ip_src, \n                        arp_tpa=ip_dst\n                    )\n                    \n                    \n                #src switch flow entry\n                actions = [ofp_parser.OFPActionOutput(final_out)]\n                        \n                self.en_clear_flow_entry=True\n                #src switch flow entry\n                self.add_flow(src_sw_dp, 32768, match_ip, actions)\n                self.add_flow(src_sw_dp, 1, match_arp, actions)\n                ##############################################################\n                #First switch in path\n                dst_sw_dp = self.datapath_list[key_val[0]]\n                final_out = single_path[key_val[0]][0]\n                print(\"first switch in the loop port number is \",final_out)\n                 \n                #print(\"initial ip is \",self.hosts)\n                print(\"Packet is recevied from port  \",self.input_port)\n                ofp = src_sw_dp.ofproto\n                ofp_parser = dst_sw_dp.ofproto_parser\n                match_ip = ofp_parser.OFPMatch(\n                        eth_type=0x0800, \n                        ipv4_src=ip_dst, \n                        ipv4_dst=ip_src\n                    )\n                match_arp = ofp_parser.OFPMatch(\n                        eth_type=0x0806, \n                        arp_spa=ip_dst, \n                        arp_tpa=ip_src\n                    )\n                    \n                    \n                #src switch flow entry\n                actions = [ofp_parser.OFPActionOutput(final_out)]\n                        \n                self.en_clear_flow_entry=True\n                #src switch flow entry\n                self.add_flow(dst_sw_dp, 32768, match_ip, actions)\n                self.add_flow(dst_sw_dp, 1, match_arp, actions)\n                #j =j+5\n                \n                \n            else:\n                src_sw_dp = self.datapath_list[key_val[j]]\n                #dst_sw_dp = self.datapath_list[key_val[j+1]] \n                #print(\"dst_sw_dp = \",dst_sw_dp)\n                print(\"out port from src switch is \",self.adjacency[key_val[j]][key_val[j+1]])\n                #print(\"in port of dst  switch is \",self.adjacency[key_val[j+1]][key_val[j]])\n                final_out= self.adjacency[key_val[j]][key_val[j+1]]\n                ofp = src_sw_dp.ofproto\n                ofp_parser = src_sw_dp.ofproto_parser\n                match_ip = ofp_parser.OFPMatch(\n                        eth_type=0x0800, \n                        ipv4_src=ip_src, \n                        ipv4_dst=ip_dst\n                    )\n                match_arp = ofp_parser.OFPMatch(\n                        eth_type=0x0806, \n                        arp_spa=ip_src, \n                        arp_tpa=ip_dst\n                    )\n                    \n                    \n                #src switch flow entry\n                actions = [ofp_parser.OFPActionOutput(final_out)]\n                        \n                self.en_clear_flow_entry=True\n                #src switch flow entry\n                self.add_flow(src_sw_dp, 32768, match_ip, actions)\n                self.add_flow(src_sw_dp, 1, match_arp, actions)\n                \n                #actions = [ofp_parser.OFPActionOutput(self.adjacency[key_val[j+1]][key_val[j]])]\n                        \n                #dst switch flow entry\n                #self.add_flow(dst_sw_dp, 32768, match_ip, actions)\n                #self.add_flow(dst_sw_dp, 1, match_arp, actions)            \n                #self.add_flow(dp, 1, match_arp, actions)            \n            \n            \n           \n        \n        \"\"\"\n        for node in switches_in_paths:\n            print(\"inside for node in switches_in_paths, node = \", node)\n\n            dp = self.datapath_list[node]\n            ofp = dp.ofproto\n            ofp_parser = dp.ofproto_parser\n\n            ports = defaultdict(list)\n            actions = []\n            i = 0\n\n            for path in paths_with_ports:\n                print(\"inside path in paths_with_ports: path = \",path)\n                if node in path:\n                    in_port = path[node][0]\n                    out_port = path[node][1]\n                    if (out_port, pw[i]) not in ports[in_port]:\n                        ports[in_port].append((out_port, pw[i]))\n                i += 1\n            print(\"ports is \",ports,\" \\n sum_of_pw = \",sum_of_pw) \n            self.en_clear_flow_entry = True\n            \n\n            for in_port in ports:\n\n                match_ip = ofp_parser.OFPMatch(\n                    eth_type=0x0800, \n                    ipv4_src=ip_src, \n                    ipv4_dst=ip_dst\n                )\n                match_arp = ofp_parser.OFPMatch(\n                    eth_type=0x0806, \n                    arp_spa=ip_src, \n                    arp_tpa=ip_dst\n                )\n\n                print (\"Line 202 in_port = \",in_port)\n                out_ports = ports[in_port]\n                print (\"out_ports = \",out_ports)\n\n                if len(out_ports) > 1:\n                    group_id = None\n                    group_new = False\n\n                    if (node, src_switch, dst_switch) not in self.multipath_group_ids:\n                        group_new = True\n                        self.multipath_group_ids[\n                            node, src_switch, dst_switch] = self.generate_openflow_gid()\n                    group_id = self.multipath_group_ids[node, src_switch, dst_switch]\n\n                    buckets = []\n                    print (\"node at \",node,\" out ports : \",out_ports)\n                    print(\"group_id = \",group_id)\n                    for port, weight in out_ports:\n                        bucket_weight =  int(round((1 - weight/sum_of_pw) * 100))\n                        bucket_action = [ofp_parser.OFPActionOutput(port)]\n                        buckets.append(\n                            ofp_parser.OFPBucket(\n                                weight=bucket_weight,\n                                watch_port=ofp.OFPG_ANY, #port,\n                                watch_group=ofp.OFPG_ANY,\n                                actions=bucket_action\n                            )\n                        )\n\n                    if group_new:\n                        req = ofp_parser.OFPGroupMod(\n                            dp, ofp.OFPGC_ADD, ofp.OFPGT_SELECT, group_id,\n                            buckets\n                        )\n                        dp.send_msg(req)\n                    else:\n                        req = ofp_parser.OFPGroupMod(\n                            dp, ofp.OFPGC_MODIFY, ofp.OFPGT_SELECT,\n                            group_id, buckets)\n                        dp.send_msg(req)\n\n                    actions = [ofp_parser.OFPActionGroup(group_id)]\n                    \n                    self.en_clear_flow_entry=True\n                    self.add_flow(dp, 32768, match_ip, actions)\n                    self.add_flow(dp, 1, match_arp, actions)\n\n                elif len(out_ports) == 1:\n                    actions = [ofp_parser.OFPActionOutput(out_ports[0][0])]\n                    self.en_clear_flow_entry=True\n                    self.add_flow(dp, 32768, match_ip, actions)\n                    self.add_flow(dp, 1, match_arp, actions)\n        print (\"Path installation finished in \", time.time() - computation_start )\n        \"\"\"\n        return paths_with_ports[0][src_switch][1]\n\n    def add_flow(self, datapath, priority, match, actions, buffer_id=None): #modify flow entry\n        # print (\"Adding flow \", match, actions)\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                             actions)]\n        print(\"en_clear_flow_entry = \",self.en_clear_flow_entry)\n        if buffer_id:\n            if(self.en_clear_flow_entry):\n                mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n                                    priority=priority, match=match,idle_timeout=idle_time,#*datapath.id,\n                                    instructions=inst)\n            else:\n                mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n                                    priority=priority, match=match,\n                                    instructions=inst)\n        else:\n            if(self.en_clear_flow_entry):\n                mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                    match=match, idle_timeout=idle_time,#*datapath.id\n                                    instructions=inst)\n            else:\n                mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                    match=match,instructions=inst)\n        datapath.send_msg(mod)\n\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER) #create miss flow entry then send it\n    def _switch_features_handler(self, ev):\n        print (\"switch_features_handler is called\")\n        datapath = ev.msg.datapath\n        print (\"switch_features_handler is called for \",datapath.id)\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        match = parser.OFPMatch()\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                          ofproto.OFPCML_NO_BUFFER)]\n        print(\"actions for called switch miss flow entry is \",actions)                                  \n        self.add_flow(datapath, 0, match, actions)\n\n    @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\n    def port_desc_stats_reply_handler(self, ev):\n        switch = ev.msg.datapath\n        for p in ev.msg.body:\n            self.bandwidths[switch.id][p.port_no] = p.curr_speed\n\n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n    def _packet_in_handler(self, ev):\n        msg = ev.msg\n        datapath = msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n        in_port = msg.match['in_port']\n\n        pkt = packet.Packet(msg.data)\n        eth = pkt.get_protocol(ethernet.ethernet)\n        arp_pkt = pkt.get_protocol(arp.arp)\n\n        # avoid broadcast from LLDP\n        if eth.ethertype == 35020:\n            return\n        if self.disable_packet_in :\n            return\n        \n        if pkt.get_protocol(ipv4.ipv4):  ##################### inhibit duplicate\n            match = parser.OFPMatch(eth_type=eth.ethertype)    \n            print(\"ip_v4 Received \")    \n            return\n\n        if pkt.get_protocol(ipv6.ipv6):  # Drop the IPV6 Packets.\n            match = parser.OFPMatch(eth_type=eth.ethertype)\n            actions = []\n            self.en_clear_flow_entry=False\n            self.add_flow(datapath, 1, match, actions)\n            return None\n\n        dst = eth.dst       #mac address of destination\n        src = eth.src       #mac address of source\n        dpid = datapath.id\n        \n\n        if src not in self.hosts:\n            self.hosts[src] = (dpid, in_port)\n            self.input_port = in_port\n            print(\"inside packetin, sel.hosts 'mac': (sw, port) is \",self.hosts)\n            print(\"inside packetin,  src not in self.hosts , dst is \",dst)\n            #after first h2 ping -c1 h1\n            #inside packetin, sel.hosts is  {'00:00:02:00:00:00': (3, 5)}\n            #inside packetin,  src not in self.hosts  ff:ff:ff:ff:ff:ff\n            #above mac is called key\n            #value switch id 3;     host is located at port 5\n\n        out_port = ofproto.OFPP_FLOOD\n\n        if arp_pkt:\n            # print (dpid, pkt)\n            src_ip = arp_pkt.src_ip\n            dst_ip = arp_pkt.dst_ip\n            if arp_pkt.opcode == arp.ARP_REPLY: # IF REPLY IS RECEIVED.\n                self.arp_table[src_ip] = src\n                print(\"arp_pkt.opcode == arp.ARP_REPLY , self.arp_table is \",self.arp_table)\n                #key of arp_table is ip, value is src_mac\n                h1 = self.hosts[src]        #(dpid, in_port)\n                h2 = self.hosts[dst]        #(dpid, in_port)\n                out_port = self.install_paths(h1[0], h1[1], h2[0], h2[1], src_ip, dst_ip)\n                #self.disable_packet_in = True\n                self.install_paths(h2[0], h2[1], h1[0], h1[1], dst_ip, src_ip) # reverse\n                #self.disable_packet_in = False\n            elif arp_pkt.opcode == arp.ARP_REQUEST: #IF REQUEST IS GOING TO INITIATED.\n                #لم يتم تجهيزه بعد\n                print(\" #لم يتم تجهيزه بعد \")\n                if dst_ip in self.arp_table:\n                    self.arp_table[src_ip] = src\n                    dst_mac = self.arp_table[dst_ip]\n                    h1 = self.hosts[src]\n                    h2 = self.hosts[dst_mac]\n                    print(\"inside ARP_REQUEST h1= \", h1 ,\" h2= \",h2, \" src_ip = \",src_ip, \" dst_ip = \",dst_ip)\n                    out_port = self.install_paths(h1[0], h1[1], h2[0], h2[1], src_ip, dst_ip)\n                    #self.disable_packet_in = False\n                    self.install_paths(h2[0], h2[1], h1[0], h1[1], dst_ip, src_ip) # reverse\n                    #self.disable_packet_in = False\n\n        print (pkt)\n\n        actions = [parser.OFPActionOutput(out_port)]\n\n        data = None\n        if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n            data = msg.data\n\n        out = parser.OFPPacketOut(\n            datapath=datapath, buffer_id=msg.buffer_id, in_port=in_port,\n            actions=actions, data=data)\n        datapath.send_msg(out)\n\n    @set_ev_cls(event.EventSwitchEnter) #update datapath_list[dpid], o/p is self.datapath_list[switch.id]\n    def switch_enter_handler(self, event):  \n        switch = event.switch.dp\n        ofp_parser = switch.ofproto_parser\n\n        if switch.id not in self.switches:\n            self.switches.append(switch.id)\n            self.datapath_list[switch.id] = switch\n\n            # Request port/link descriptions, useful for obtaining bandwidth\n            req = ofp_parser.OFPPortDescStatsRequest(switch)\n            switch.send_msg(req)\n\n    @set_ev_cls(event.EventSwitchLeave, MAIN_DISPATCHER) #del datapath_list[dpid], del adjacency\n    def switch_leave_handler(self, event):\n        print( event)\n        switch = event.switch.dp.id\n        if switch in self.switches:\n            del self.switches[switch]\n            del self.datapath_list[switch]\n            del self.adjacency[switch]\n\n    @set_ev_cls(event.EventLinkAdd, MAIN_DISPATCHER) #create self.adjacency\n    def link_add_handler(self, event):\n        s1 = event.link.src\n        #print(\"EventLinkAdd ; event.link.src = \",s1)\n        s2 = event.link.dst\n        #print(\"EventLinkAdd ; event.link.dst = \",s2)\n        self.adjacency[s1.dpid][s2.dpid] = s1.port_no\n        self.adjacency[s2.dpid][s1.dpid] = s2.port_no\n        #print(\"1: {4: 3, 2: 2} means details of switch s1 is connected to s4 via s1-eth3; and is connected to s2 via s1-eth2\")\n        #print(\"EventLinkAdd ; adjacency is \",self.adjacency)\n\n    @set_ev_cls(event.EventLinkDelete, MAIN_DISPATCHER)\n    def link_delete_handler(self, event):\n        #print(\"EventLinkdelete ; event.link.src = \",event.link.src)\n        #print(\"EventLinkdelete ; event.link.dst = \",event.link.dst)\n        #print(\"val of  self.adjacency[event.link.src.dpid][event.link.dst.dpid] is \",self.adjacency[event.link.src.dpid][event.link.dst.dpid])\n        del self.adjacency[event.link.src.dpid][event.link.dst.dpid]\n        new_dic=self.adjacency\n        key_val= [key_val for key_val in new_dic.keys()]\n        #print(\"key_val = \",key_val)\n        #del new_dic[event.link.src.dpid]\n        #k = event.link.src.dpid\n        #for key_val in new_dic.keys():\n        #print( \"new_dic = \",new_dic)\n        return"
        }
    ]
}
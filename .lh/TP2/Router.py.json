{
    "sourceFile": "TP2/Router.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1655562747406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1655567367240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,12 @@\n UDP = udp.udp.__name__\r\n \r\n \r\n \r\n+interface_port_to_ip = {1: {1: '191.0.0.254', 2: '12.0.0.253', 3: '13.0.0.253'},\r\n+                        2: {1: '192.0.0.254', 2: '12.0.0.254', 3: '23.0.0.253'},\r\n+                        3: {1: '193.0.0.254', 2: '13.0.0.254', 3: '23.0.0.254'}\r\n+                        }\r\n \r\n class SwitchL3(app_manager.RyuApp):\r\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\r\n \r\n@@ -38,14 +42,15 @@\n         - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\r\n         - packet_queue: dicionario fila de pacotes arp\r\n     \"\"\"\r\n \r\n+\r\n     def __init__(self, *args, **kwargs):\r\n         super(SwitchL3, self).__init__(*args, **kwargs)\r\n         self.ip_to_mac = {}\r\n-        self.ip_to_port = {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1,\r\n-                           '10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2,\r\n-                           '10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3,}\r\n+        self.ip_to_port = {'10.0.1.2' : 1, '20.0.0.253' : 1, '30.0.0.253' : 1,\r\n+                           '10.0.2.2' : 2, '20.0.0.254' : 2, '40.0.0.253' : 2,\r\n+                           '10.0.3.2' : 3, '30.0.0.254' : 3, '40.0.0.254' : 3,}\r\n         self.router_ports = {}\r\n         self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\r\n         \r\n         self.packet_queue = {}\r\n"
                },
                {
                    "date": 1655606506054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,12 +26,8 @@\n UDP = udp.udp.__name__\r\n \r\n \r\n \r\n-interface_port_to_ip = {1: {1: '191.0.0.254', 2: '12.0.0.253', 3: '13.0.0.253'},\r\n-                        2: {1: '192.0.0.254', 2: '12.0.0.254', 3: '23.0.0.253'},\r\n-                        3: {1: '193.0.0.254', 2: '13.0.0.254', 3: '23.0.0.254'}\r\n-                        }\r\n \r\n class SwitchL3(app_manager.RyuApp):\r\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\r\n \r\n@@ -46,22 +42,18 @@\n \r\n     def __init__(self, *args, **kwargs):\r\n         super(SwitchL3, self).__init__(*args, **kwargs)\r\n         self.ip_to_mac = {}\r\n-        self.ip_to_port = {'10.0.1.2' : 1, '20.0.0.253' : 1, '30.0.0.253' : 1,\r\n-                           '10.0.2.2' : 2, '20.0.0.254' : 2, '40.0.0.253' : 2,\r\n-                           '10.0.3.2' : 3, '30.0.0.254' : 3, '40.0.0.254' : 3,}\r\n+        self.ip_to_port = {\r\n+                           '0000000000000001':{'10.0.1.2' : 1, '20.0.0.253' : 1, '30.0.0.253' : 1},\r\n+                           '0000000000000002':{'10.0.2.2' : 2, '20.0.0.254' : 2, '40.0.0.253' : 2},\r\n+                           '0000000000000003':{'10.0.3.2' : 3, '30.0.0.254' : 3, '40.0.0.254' : 3}\r\n+                            }\r\n         self.router_ports = {}\r\n         self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\r\n         \r\n         self.packet_queue = {}\r\n         \r\n-        self.routers = {}\r\n-        self.routes = {} # Rotas aprendidas para cada um dos routers\r\n-        self.updates = {} # Updates na tabela \r\n-        self.groupID = {} # Identificadores para cada dispositivo\r\n-        \r\n-        \r\n \r\n \r\n     \"\"\"\r\n     Função responsável pelo evento correspondente ao ennvio das funcionaliades presentes no switch para o controlado\r\n"
                },
                {
                    "date": 1655607094351,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,17 +42,20 @@\n \r\n     def __init__(self, *args, **kwargs):\r\n         super(SwitchL3, self).__init__(*args, **kwargs)\r\n         self.ip_to_mac = {}\r\n-        self.ip_to_port = {\r\n-                           '0000000000000001':{'10.0.1.2' : 1, '20.0.0.253' : 1, '30.0.0.253' : 1},\r\n-                           '0000000000000002':{'10.0.2.2' : 2, '20.0.0.254' : 2, '40.0.0.253' : 2},\r\n-                           '0000000000000003':{'10.0.3.2' : 3, '30.0.0.254' : 3, '40.0.0.254' : 3}\r\n-                            }\r\n+        self.ip_to_mac = {}\r\n+        self.ip_to_port = {  \r\n+                          '0000000000000004':{'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1},\r\n+                          '0000000000000005' :{'10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2},\r\n+                          '0000000000000006' : {3, '10.0.3.3' : 3, '10.0.3.4' : 3}\r\n+              }\r\n+    \r\n         self.router_ports = {}\r\n         self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\r\n         \r\n         self.packet_queue = {}\r\n+ \r\n         \r\n \r\n \r\n     \"\"\"\r\n"
                },
                {
                    "date": 1655607234139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,15 +44,19 @@\n         super(SwitchL3, self).__init__(*args, **kwargs)\r\n         self.ip_to_mac = {}\r\n         self.ip_to_mac = {}\r\n         self.ip_to_port = {  \r\n-                          '0000000000000004':{'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1},\r\n-                          '0000000000000005' :{'10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2},\r\n-                          '0000000000000006' : {3, '10.0.3.3' : 3, '10.0.3.4' : 3}\r\n-              }\r\n+                          '0000000000000004':  {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1},\r\n+                          '0000000000000005' : {'10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2},\r\n+                          '0000000000000006' : {'10.0.3.2': 3, '10.0.3.3' : 3, '10.0.3.4' : 3}\r\n+                          }\r\n     \r\n         self.router_ports = {}\r\n-        self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\r\n+        self.router_ports_to_ip = {\r\n+                                    '0000000000000001' :{1 : '10.0.1.1'},\r\n+                                    '0000000000000002' :{2 : '10.0.2.1'},\r\n+                                    '0000000000000003' :{3 : '10.0.3.1'}\r\n+                                  }\r\n         \r\n         self.packet_queue = {}\r\n  \r\n         \r\n"
                },
                {
                    "date": 1655607358790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,11 +51,11 @@\n                           }\r\n     \r\n         self.router_ports = {}\r\n         self.router_ports_to_ip = {\r\n-                                    '0000000000000001' :{1 : '10.0.1.1'},\r\n-                                    '0000000000000002' :{2 : '10.0.2.1'},\r\n-                                    '0000000000000003' :{3 : '10.0.3.1'}\r\n+                                    '0000000000000001':{1 : '10.0.1.1', 2: '20.0.0.253', 3 : '30.0.0.253'},\r\n+                                    '0000000000000002':{1 : '10.0.2.1', 2: '20.0.0.254', 3: '40.0.0.253'}, \r\n+                                    '0000000000000003':{1 : '10.0.3.1', 2: '30.0.0.254', 3: '40.0.0.254'}\r\n                                   }\r\n         \r\n         self.packet_queue = {}\r\n  \r\n"
                },
                {
                    "date": 1655607376213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,11 +51,11 @@\n                           }\r\n     \r\n         self.router_ports = {}\r\n         self.router_ports_to_ip = {\r\n-                                    '0000000000000001':{1 : '10.0.1.1', 2: '20.0.0.253', 3 : '30.0.0.253'},\r\n-                                    '0000000000000002':{1 : '10.0.2.1', 2: '20.0.0.254', 3: '40.0.0.253'}, \r\n-                                    '0000000000000003':{1 : '10.0.3.1', 2: '30.0.0.254', 3: '40.0.0.254'}\r\n+                                    '0000000000000001':{1:'10.0.1.1', 2:'20.0.0.253', 3:'30.0.0.253'},\r\n+                                    '0000000000000002':{1:'10.0.2.1', 2:'20.0.0.254', 3:'40.0.0.253'}, \r\n+                                    '0000000000000003':{1:'10.0.3.1', 2:'30.0.0.254', 3:'40.0.0.254'}\r\n                                   }\r\n         \r\n         self.packet_queue = {}\r\n  \r\n"
                },
                {
                    "date": 1655607599548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,20 +140,20 @@\n             self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\r\n             return\r\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\r\n         if pkt_ipv4:\r\n-            if pkt_ipv4.dst in self.router_ports_to_ip.values():\r\n+            if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\r\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\r\n                 if pkt_icmp:\r\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\r\n                     return\r\n             else:\r\n                 #Static routing handling\r\n-                if pkt_ipv4.dst in self.ip_to_port.keys():\r\n+                if pkt_ipv4.dst in self.ip_to_port[dpid].keys():\r\n                     self.logger.info(\"\\nPacket received by router %s from %s to %s \", dpid, pkt_ipv4.src, pkt_ipv4.dst)\r\n                     self.ip_to_mac.setdefault(dpid, {})\r\n                     if pkt_ipv4.dst in self.ip_to_mac[dpid].keys():\r\n-                        out_port = self.ip_to_port[pkt_ipv4.dst]\r\n+                        out_port = self.ip_to_port[dpid][pkt_ipv4.dst]\r\n                         pkt_ethernet.src = self.router_ports[dpid][out_port]\r\n                         pkt_ethernet.dst = self.ip_to_mac[dpid][pkt_ipv4.dst]\r\n                         self.send_packet(msg.datapath,out_port,pkt)\r\n                         return\r\n@@ -173,11 +173,12 @@\n                    \r\n \r\n     #Enviar arp request\r\n     def send_arp_request(self, msg, pkt_ipv4):\r\n-        out_port = self.ip_to_port[pkt_ipv4.dst]\r\n+        dpid = msg.datapath.id\r\n+        out_port = self.ip_to_port[dpid][pkt_ipv4.dst]\r\n         src_mac = self.router_ports[msg.datapath.id][out_port]\r\n-        src_ip = self.router_ports_to_ip[out_port]\r\n+        src_ip = self.router_ports_to_ip[dpid][out_port]\r\n \r\n \r\n         pkt = packet.Packet()\r\n         pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\r\n@@ -211,9 +212,9 @@\n     def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\r\n         #ARP packet handling.\r\n         dpid = msg.datapath.id\r\n \r\n-        if pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REQUEST:\r\n+        if pkt_arp.dst_ip in [self.router_ports_to_ip][dpid].values() and pkt_arp.opcode == arp.ARP_REQUEST:\r\n \r\n             self.logger.info(\"\\nARP Request received by router %s from %s in port %s \", dpid, pkt_arp.src_ip, port)\r\n \r\n             port_mac = self.router_ports[dpid][port]\r\n@@ -231,9 +232,9 @@\n \r\n             self.logger.info(\"ARP Reply sent by router %s from port %s with MAC %s to %s\", dpid, port, port_mac, pkt_arp.src_ip)\r\n \r\n             return\r\n-        elif pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REPLY:\r\n+        elif pkt_arp.dst_ip in [self.router_ports_to_ip][dpid].values() and pkt_arp.opcode == arp.ARP_REPLY:\r\n             self.logger.info(\"\\nARP Reply received by router %s from %s with MAC %s\", dpid, pkt_arp.src_ip, pkt_arp.src_mac)\r\n             self.ip_to_mac.setdefault(dpid, {})\r\n             self.ip_to_mac[dpid][pkt_arp.src_ip] = pkt_arp.src_mac\r\n \r\n@@ -241,9 +242,9 @@\n                 dpid = m.datapath.id        \r\n                 pkt = packet.Packet(m.data)\r\n                 pkt_eth = pkt.get_protocol(ethernet.ethernet)\r\n                 pkt_v4 = pkt.get_protocol(ipv4.ipv4)\r\n-                out_port = self.ip_to_port[pkt_arp.src_ip]\r\n+                out_port = self.ip_to_port[dpid][pkt_arp.src_ip]\r\n                 pkt_eth.src = self.router_ports[dpid][out_port]\r\n                 pkt_eth.dst = self.ip_to_mac[dpid][pkt_arp.src_ip]\r\n                 self.send_packet(msg.datapath,out_port,pkt)\r\n                 self.logger.info(\"Router %s sent queued packet from %s to %s\", dpid, pkt_v4.src, pkt_v4.dst)\r\n@@ -268,9 +269,9 @@\n         pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n                                            dst=pkt_ethernet.src,\r\n                                            src=self.router_ports[dpid][port]))\r\n         pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n-                                   src=self.router_ports_to_ip[port],\r\n+                                   src=self.router_ports_to_ip[dpid][port],\r\n                                    proto=pkt_ipv4.proto))\r\n         pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\r\n                                    code=icmp.ICMP_ECHO_REPLY_CODE,\r\n                                    csum=0,\r\n@@ -306,8 +307,9 @@\n         self.logger.info(\"Entrada na flow table adicionada!\")\r\n         \r\n         \r\n     def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\r\n+        dpid = msg.datapath.id\r\n         port_mac = self.router_ports[msg.datapath.id][port]\r\n \r\n         offset = ethernet.ethernet._MIN_LEN\r\n         end_of_data = offset + len(pkt_ipv4) + 128\r\n@@ -325,9 +327,9 @@\n         pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n                                             dst=pkt_ethernet.src,\r\n                                             src=port_mac))\r\n         pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n-                                    src=self.router_ports_to_ip[port],\r\n+                                    src=self.router_ports_to_ip[dpid][port],\r\n                                     proto=pkt_ipv4.proto))\r\n         pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_DEST_UNREACH,\r\n                                     code=icmp.ICMP_HOST_UNREACH_CODE,\r\n                                     csum=0,\r\n"
                },
                {
                    "date": 1655608091781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,340 +1,340 @@\n-from email import parser\r\n-from ryu.base import app_manager\r\n-from ryu.controller import ofp_event\r\n-from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\r\n-from ryu.controller.handler import set_ev_cls\r\n-from ryu.ofproto import ofproto_v1_3\r\n-from ryu.lib.packet import packet\r\n-from ryu.lib.packet import ether_types\r\n-from ryu.lib.packet import packet_base\r\n-from ryu.lib.packet import ethernet\r\n-from ryu.lib.packet import arp\r\n-from ryu.lib.packet import ethernet\r\n-from ryu.lib.packet import icmp\r\n-from ryu.lib.packet import ipv4\r\n-from ryu.lib.packet import packet\r\n-from ryu.lib.packet import packet_base\r\n-from ryu.lib.packet import tcp\r\n-from ryu.lib.packet import udp\r\n-from ryu.ofproto import ether\r\n-\r\n-ETHERNET = ethernet.ethernet.__name__\r\n-IPV4 = ipv4.ipv4.__name__\r\n-ARP = arp.arp.__name__\r\n-ICMP = icmp.icmp.__name__\r\n-TCP = tcp.tcp.__name__\r\n-UDP = udp.udp.__name__\r\n-\r\n-\r\n-\r\n-\r\n-class SwitchL3(app_manager.RyuApp):\r\n-    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\r\n-\r\n-    \"\"\"Contrutor para a classe com as seguintes tabelas:\r\n-        - ip_to_mac: dicionario de ip para mac\r\n-        - ip_to_port: dicionario de ip para porta (L3)\r\n-        - router_ports: dicionario de porta para ip \r\n-        - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\r\n-        - packet_queue: dicionario fila de pacotes arp\r\n-    \"\"\"\r\n-\r\n-\r\n-    def __init__(self, *args, **kwargs):\r\n-        super(SwitchL3, self).__init__(*args, **kwargs)\r\n-        self.ip_to_mac = {}\r\n-        self.ip_to_mac = {}\r\n-        self.ip_to_port = {  \r\n-                          '0000000000000004':  {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1},\r\n-                          '0000000000000005' : {'10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2},\r\n-                          '0000000000000006' : {'10.0.3.2': 3, '10.0.3.3' : 3, '10.0.3.4' : 3}\r\n-                          }\r\n-    \r\n-        self.router_ports = {}\r\n-        self.router_ports_to_ip = {\r\n-                                    '0000000000000001':{1:'10.0.1.1', 2:'20.0.0.253', 3:'30.0.0.253'},\r\n-                                    '0000000000000002':{1:'10.0.2.1', 2:'20.0.0.254', 3:'40.0.0.253'}, \r\n-                                    '0000000000000003':{1:'10.0.3.1', 2:'30.0.0.254', 3:'40.0.0.254'}\r\n-                                  }\r\n-        \r\n-        self.packet_queue = {}\r\n- \r\n-        \r\n-\r\n-\r\n-    \"\"\"\r\n-    Função responsável pelo evento correspondente ao ennvio das funcionaliades presentes no switch para o controlado\r\n-    \"\"\"\r\n-    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\r\n-    def switch_features_handler(self, ev):\r\n-        datapath = ev.msg.datapath\r\n-        ofproto = datapath.ofproto\r\n-        parser = datapath.ofproto_parser\r\n-\r\n-        match = parser.OFPMatch()\r\n-        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]\r\n-\r\n-        self.add_flow(datapath, 0, match, actions)\r\n-\r\n-        match = parser.OFPMatch(eth_type = ether_types.ETH_TYPE_IPV6)\r\n-        actions = []\r\n-\r\n-        self.add_flow(datapath, 1, match, actions)\r\n-        self.port_desc(datapath)\r\n-\r\n-    #Utility Function\r\n-    def port_desc(self, datapath):\r\n-        ofparser = datapath.ofproto_parser\r\n-\r\n-        req = ofparser.OFPPortDescStatsRequest(datapath,0)\r\n-        datapath.send_msg(req)\r\n-\r\n-    #Utility Function\r\n-    @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\r\n-    def port_desc_stats_reply_handle(self,ev):\r\n-\r\n-        dpid = ev.msg.datapath.id\r\n-        self.router_ports.setdefault(dpid, {})\r\n-        for p in ev.msg.body:\r\n-            self.router_ports[dpid].update({ p.port_no: p.hw_addr})\r\n-        \r\n-        print(\"L3 Switches Conectado dpid:\",dpid)\r\n-        for p in self.router_ports[dpid].keys():\r\n-            if p < 10:\r\n-                print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\r\n-                print(\"Cada Port Corresponde a uma subnet\")\r\n-        print(\"\\n\")\r\n-\r\n-    #Adcionar flows\r\n-    def add_flow(self, datapath, priority, match, actions, buffer_id=None):\r\n-        ofproto = datapath.ofproto\r\n-        parser = datapath.ofproto_parser\r\n-\r\n-        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\r\n-                                             actions)]\r\n-        if buffer_id:\r\n-            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\r\n-                                    priority=priority, match=match,\r\n-                                    instructions=inst)\r\n-        else:\r\n-            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\r\n-                                    match=match, instructions=inst)\r\n-        datapath.send_msg(mod)\r\n- \r\n-    #Gestão de pacotes\r\n-    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\r\n-    def packet_in_handler(self, ev):\r\n-        msg = ev.msg\r\n-        dpid = msg.datapath.id        \r\n-        port = msg.match['in_port']\r\n-        pkt = packet.Packet(msg.data)\r\n-\r\n-        #self.logger.info(\"\\npacket-in %s\" % (pkt,))\r\n-\r\n-        pkt_ethernet = pkt.get_protocol(ethernet.ethernet)\r\n-        if not pkt_ethernet:\r\n-            return\r\n-        pkt_arp = pkt.get_protocol(arp.arp)\r\n-        if pkt_arp:\r\n-            #ARP handling\r\n-            self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\r\n-            return\r\n-        pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\r\n-        if pkt_ipv4:\r\n-            if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\r\n-                pkt_icmp = pkt.get_protocol(icmp.icmp)\r\n-                if pkt_icmp:\r\n-                    self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\r\n-                    return\r\n-            else:\r\n-                #Static routing handling\r\n-                if pkt_ipv4.dst in self.ip_to_port[dpid].keys():\r\n-                    self.logger.info(\"\\nPacket received by router %s from %s to %s \", dpid, pkt_ipv4.src, pkt_ipv4.dst)\r\n-                    self.ip_to_mac.setdefault(dpid, {})\r\n-                    if pkt_ipv4.dst in self.ip_to_mac[dpid].keys():\r\n-                        out_port = self.ip_to_port[dpid][pkt_ipv4.dst]\r\n-                        pkt_ethernet.src = self.router_ports[dpid][out_port]\r\n-                        pkt_ethernet.dst = self.ip_to_mac[dpid][pkt_ipv4.dst]\r\n-                        self.send_packet(msg.datapath,out_port,pkt)\r\n-                        return\r\n-\r\n-                    else:\r\n-                        #Send ARP Request\r\n-                        self.packet_queue.setdefault(pkt_ipv4.dst,[])\r\n-                        self.packet_queue[pkt_ipv4.dst].append(msg)\r\n-                        self.logger.info(\"\\nRouter %s doesn't know MAC of %s adding packet to queue\", dpid, pkt_ipv4.dst)\r\n-                        self.send_arp_request(msg, pkt_ipv4)\r\n-                        return\r\n-\r\n-                else:\r\n-                    self.logger.info(\"\\nPacket received by router %s from %s to %s (unknown destination)\", dpid, pkt_ipv4.src, pkt_ipv4.dst)\r\n-                    self.send_icmp_unreachable(msg, port, pkt_ethernet, pkt_ipv4)\r\n-                    #Send ICMP network unreachable\r\n-                   \r\n-\r\n-    #Enviar arp request\r\n-    def send_arp_request(self, msg, pkt_ipv4):\r\n-        dpid = msg.datapath.id\r\n-        out_port = self.ip_to_port[dpid][pkt_ipv4.dst]\r\n-        src_mac = self.router_ports[msg.datapath.id][out_port]\r\n-        src_ip = self.router_ports_to_ip[dpid][out_port]\r\n-\r\n-\r\n-        pkt = packet.Packet()\r\n-        pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\r\n-                                           dst='ff:ff:ff:ff:ff:ff',\r\n-                                           src=src_mac))\r\n-        pkt.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\r\n-                                 src_mac=src_mac,\r\n-                                 src_ip=src_ip,\r\n-                                 dst_mac='ff:ff:ff:ff:ff:ff',\r\n-                                 dst_ip=pkt_ipv4.dst))\r\n-\r\n-        self.send_packet(msg.datapath,out_port,pkt)\r\n-\r\n-        self.logger.info(\"\\nRouter %s sending ARP Request from port %s to learn MAC of %s\", msg.datapath.id, out_port, pkt_ipv4.dst)\r\n-\r\n-    #Enviar pacote\r\n-    def send_packet(self, datapath, port, pkt):\r\n-        ofproto = datapath.ofproto\r\n-        parser = datapath.ofproto_parser\r\n-        pkt.serialize()\r\n-        data = pkt.data\r\n-        actions = [parser.OFPActionOutput(port=port)]\r\n-        out = parser.OFPPacketOut(datapath=datapath,\r\n-                                  buffer_id=ofproto.OFP_NO_BUFFER,\r\n-                                  in_port=ofproto.OFPP_CONTROLLER,\r\n-                                  actions=actions,\r\n-                                  data=data)\r\n-        datapath.send_msg(out)\r\n-\r\n-    #Gerir arp requests\r\n-    def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\r\n-        #ARP packet handling.\r\n-        dpid = msg.datapath.id\r\n-\r\n-        if pkt_arp.dst_ip in [self.router_ports_to_ip][dpid].values() and pkt_arp.opcode == arp.ARP_REQUEST:\r\n-\r\n-            self.logger.info(\"\\nARP Request received by router %s from %s in port %s \", dpid, pkt_arp.src_ip, port)\r\n-\r\n-            port_mac = self.router_ports[dpid][port]\r\n-\r\n-            pkt = packet.Packet()\r\n-            pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\r\n-                                           dst=pkt_ethernet.src,\r\n-                                           src=port_mac))\r\n-            pkt.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\r\n-                                 src_mac=port_mac,\r\n-                                 src_ip=pkt_arp.dst_ip,\r\n-                                 dst_mac=pkt_arp.src_mac,\r\n-                                 dst_ip=pkt_arp.src_ip))\r\n-            self.send_packet(msg.datapath, port, pkt)\r\n-\r\n-            self.logger.info(\"ARP Reply sent by router %s from port %s with MAC %s to %s\", dpid, port, port_mac, pkt_arp.src_ip)\r\n-\r\n-            return\r\n-        elif pkt_arp.dst_ip in [self.router_ports_to_ip][dpid].values() and pkt_arp.opcode == arp.ARP_REPLY:\r\n-            self.logger.info(\"\\nARP Reply received by router %s from %s with MAC %s\", dpid, pkt_arp.src_ip, pkt_arp.src_mac)\r\n-            self.ip_to_mac.setdefault(dpid, {})\r\n-            self.ip_to_mac[dpid][pkt_arp.src_ip] = pkt_arp.src_mac\r\n-\r\n-            for m in self.packet_queue[pkt_arp.src_ip]:\r\n-                dpid = m.datapath.id        \r\n-                pkt = packet.Packet(m.data)\r\n-                pkt_eth = pkt.get_protocol(ethernet.ethernet)\r\n-                pkt_v4 = pkt.get_protocol(ipv4.ipv4)\r\n-                out_port = self.ip_to_port[dpid][pkt_arp.src_ip]\r\n-                pkt_eth.src = self.router_ports[dpid][out_port]\r\n-                pkt_eth.dst = self.ip_to_mac[dpid][pkt_arp.src_ip]\r\n-                self.send_packet(msg.datapath,out_port,pkt)\r\n-                self.logger.info(\"Router %s sent queued packet from %s to %s\", dpid, pkt_v4.src, pkt_v4.dst)\r\n-\r\n-  \r\n-            #cycle through all packets to this ip and forward them\r\n-            return\r\n-        else:\r\n-            self.logger.info(\"\\nARP Packet dropped router %s, %s not an interface ip\", dpid, pkt_arp.dst_ip)\r\n-            \r\n-            #Any other case pass\r\n-            return\r\n-\r\n-\r\n-    def handle_icmp(self, msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp):\r\n-        # Send ICMP echo reply.\r\n-\r\n-        dpid = msg.datapath.id\r\n-        src_ip = pkt_ipv4.src\r\n-        self.logger.info('\\nICMP echo request received by router %s port %s from %s to %s.', dpid, port, src_ip, pkt_ipv4.dst)\r\n-        pkt = packet.Packet()\r\n-        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n-                                           dst=pkt_ethernet.src,\r\n-                                           src=self.router_ports[dpid][port]))\r\n-        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n-                                   src=self.router_ports_to_ip[dpid][port],\r\n-                                   proto=pkt_ipv4.proto))\r\n-        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\r\n-                                   code=icmp.ICMP_ECHO_REPLY_CODE,\r\n-                                   csum=0,\r\n-                                   data=pkt_icmp.data))\r\n-        self.send_packet(msg.datapath, port, pkt)\r\n-        self.logger.info('Send ICMP echo reply to [%s].', src_ip)\r\n-        \r\n-        match = parser.OFPMatch(in_port = port,\r\n-                                eth_type=0x0800,\r\n-                                ip_proto=pkt_ipv4.proto,\r\n-                                ipv4_src=pkt_ipv4.src,\r\n-                                ipv4_dst=pkt_ipv4.dst)\r\n-        \r\n-        #Inversao de endereços IPv4 e MAC para resopnder, e o tipo de código de ICMP alterados para reply.\r\n-        set_csum = parser.OFPActionSetField(ipv4_csum=0)\r\n-        set_eth_src = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\r\n-        set_eth_dst = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\r\n-        set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\r\n-        set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\r\n-        set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\r\n-        set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\r\n-        actions = [set_csum, set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\r\n-        \r\n-        self.add_flow(msg.datapath, 2, match, actions)\r\n-        out = msg.ofproto_parser.OFPPacketOut(datapath=msg.datapath,\r\n-                                              buffer_id=0xffffffff,\r\n-                                              in_port=msg.ofproto.OFPP_CONTROLLER,\r\n-                                              actions=actions,\r\n-                                              data=packet)\r\n-        msg.datapath.send_msg(out)\r\n-        \r\n-        \r\n-        self.logger.info(\"Entrada na flow table adicionada!\")\r\n-        \r\n-        \r\n-    def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\r\n-        dpid = msg.datapath.id\r\n-        port_mac = self.router_ports[msg.datapath.id][port]\r\n-\r\n-        offset = ethernet.ethernet._MIN_LEN\r\n-        end_of_data = offset + len(pkt_ipv4) + 128\r\n-        ip_datagram = bytearray()\r\n-        ip_datagram += msg.data[offset:end_of_data]\r\n-        data_len = int(len(ip_datagram) / 4)\r\n-        length_modulus = int(len(ip_datagram) % 4)\r\n-        if length_modulus:\r\n-            data_len += 1\r\n-            ip_datagram += bytearray([0] * (4 - length_modulus))\r\n-\r\n-        icmp_data = icmp.dest_unreach(data_len=data_len, data=ip_datagram)\r\n-\r\n-        pkt = packet.Packet()\r\n-        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n-                                            dst=pkt_ethernet.src,\r\n-                                            src=port_mac))\r\n-        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n-                                    src=self.router_ports_to_ip[dpid][port],\r\n-                                    proto=pkt_ipv4.proto))\r\n-        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_DEST_UNREACH,\r\n-                                    code=icmp.ICMP_HOST_UNREACH_CODE,\r\n-                                    csum=0,\r\n-                                    data=icmp_data))\r\n-        self.send_packet(msg.datapath, port, pkt)\r\n-\r\n-        self.logger.info(\"Router %s sending ICMP Destination Unreachable to %s\", msg.datapath.id, pkt_ipv4.src)\r\n-\r\n+from email import parser\n+from ryu.base import app_manager\n+from ryu.controller import ofp_event\n+from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\n+from ryu.controller.handler import set_ev_cls\n+from ryu.ofproto import ofproto_v1_3\n+from ryu.lib.packet import packet\n+from ryu.lib.packet import ether_types\n+from ryu.lib.packet import packet_base\n+from ryu.lib.packet import ethernet\n+from ryu.lib.packet import arp\n+from ryu.lib.packet import ethernet\n+from ryu.lib.packet import icmp\n+from ryu.lib.packet import ipv4\n+from ryu.lib.packet import packet\n+from ryu.lib.packet import packet_base\n+from ryu.lib.packet import tcp\n+from ryu.lib.packet import udp\n+from ryu.ofproto import ether\n+\n+ETHERNET = ethernet.ethernet.__name__\n+IPV4 = ipv4.ipv4.__name__\n+ARP = arp.arp.__name__\n+ICMP = icmp.icmp.__name__\n+TCP = tcp.tcp.__name__\n+UDP = udp.udp.__name__\n+\n+\n+\n+\n+class SwitchL3(app_manager.RyuApp):\n+    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n+\n+    \"\"\"Contrutor para a classe com as seguintes tabelas:\n+        - ip_to_mac: dicionario de ip para mac\n+        - ip_to_port: dicionario de ip para porta (L3)\n+        - router_ports: dicionario de porta para ip \n+        - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\n+        - packet_queue: dicionario fila de pacotes arp\n+    \"\"\"\n+\n+\n+    def __init__(self, *args, **kwargs):\n+        super(SwitchL3, self).__init__(*args, **kwargs)\n+        self.ip_to_mac = {}\n+        self.ip_to_mac = {}\n+        self.ip_to_port = {  \n+                          4:  {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1},\n+                          5 : {'10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2},\n+                          6 : {'10.0.3.2': 3, '10.0.3.3' : 3, '10.0.3.4' : 3}\n+                          }\n+    \n+        self.router_ports = {}\n+        self.router_ports_to_ip = {\n+                                    1 :{1:'10.0.1.1', 2:'20.0.0.253', 3:'30.0.0.253'},\n+                                    2 :{1:'10.0.2.1', 2:'20.0.0.254', 3:'40.0.0.253'}, \n+                                    3 :{1:'10.0.3.1', 2:'30.0.0.254', 3:'40.0.0.254'}\n+                                  }\n+        \n+        self.packet_queue = {}\n+ \n+        \n+\n+\n+    \"\"\"\n+    Função responsável pelo evento correspondente ao ennvio das funcionaliades presentes no switch para o controlado\n+    \"\"\"\n+    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n+    def switch_features_handler(self, ev):\n+        datapath = ev.msg.datapath\n+        ofproto = datapath.ofproto\n+        parser = datapath.ofproto_parser\n+\n+        match = parser.OFPMatch()\n+        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]\n+\n+        self.add_flow(datapath, 0, match, actions)\n+\n+        match = parser.OFPMatch(eth_type = ether_types.ETH_TYPE_IPV6)\n+        actions = []\n+\n+        self.add_flow(datapath, 1, match, actions)\n+        self.port_desc(datapath)\n+\n+    #Utility Function\n+    def port_desc(self, datapath):\n+        ofparser = datapath.ofproto_parser\n+\n+        req = ofparser.OFPPortDescStatsRequest(datapath,0)\n+        datapath.send_msg(req)\n+\n+    #Utility Function\n+    @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\n+    def port_desc_stats_reply_handle(self,ev):\n+\n+        dpid = ev.msg.datapath.id\n+        self.router_ports.setdefault(dpid, {})\n+        for p in ev.msg.body:\n+            self.router_ports[dpid].update({ p.port_no: p.hw_addr})\n+        \n+        print(\"L3 Switches Conectado dpid:\",dpid)\n+        for p in self.router_ports[dpid].keys():\n+            if p < 10:\n+                print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\n+                print(\"Cada Port Corresponde a uma subnet\")\n+        print(\"\\n\")\n+\n+    #Adcionar flows\n+    def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n+        ofproto = datapath.ofproto\n+        parser = datapath.ofproto_parser\n+\n+        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n+                                             actions)]\n+        if buffer_id:\n+            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n+                                    priority=priority, match=match,\n+                                    instructions=inst)\n+        else:\n+            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n+                                    match=match, instructions=inst)\n+        datapath.send_msg(mod)\n+ \n+    #Gestão de pacotes\n+    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n+    def packet_in_handler(self, ev):\n+        msg = ev.msg\n+        dpid = msg.datapath.id        \n+        port = msg.match['in_port']\n+        pkt = packet.Packet(msg.data)\n+\n+        #self.logger.info(\"\\npacket-in %s\" % (pkt,))\n+\n+        pkt_ethernet = pkt.get_protocol(ethernet.ethernet)\n+        if not pkt_ethernet:\n+            return\n+        pkt_arp = pkt.get_protocol(arp.arp)\n+        if pkt_arp:\n+            #ARP handling\n+            self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n+            return\n+        pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n+        if pkt_ipv4:\n+            if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n+                pkt_icmp = pkt.get_protocol(icmp.icmp)\n+                if pkt_icmp:\n+                    self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n+                    return\n+            else:\n+                #Static routing handling\n+                if pkt_ipv4.dst in self.ip_to_port[dpid].keys():\n+                    self.logger.info(\"\\nPacket received by router %s from %s to %s \", dpid, pkt_ipv4.src, pkt_ipv4.dst)\n+                    self.ip_to_mac.setdefault(dpid, {})\n+                    if pkt_ipv4.dst in self.ip_to_mac[dpid].keys():\n+                        out_port = self.ip_to_port[dpid][pkt_ipv4.dst]\n+                        pkt_ethernet.src = self.router_ports[dpid][out_port]\n+                        pkt_ethernet.dst = self.ip_to_mac[dpid][pkt_ipv4.dst]\n+                        self.send_packet(msg.datapath,out_port,pkt)\n+                        return\n+\n+                    else:\n+                        #Send ARP Request\n+                        self.packet_queue.setdefault(pkt_ipv4.dst,[])\n+                        self.packet_queue[pkt_ipv4.dst].append(msg)\n+                        self.logger.info(\"\\nRouter %s doesn't know MAC of %s adding packet to queue\", dpid, pkt_ipv4.dst)\n+                        self.send_arp_request(msg, pkt_ipv4)\n+                        return\n+\n+                else:\n+                    self.logger.info(\"\\nPacket received by router %s from %s to %s (unknown destination)\", dpid, pkt_ipv4.src, pkt_ipv4.dst)\n+                    self.send_icmp_unreachable(msg, port, pkt_ethernet, pkt_ipv4)\n+                    #Send ICMP network unreachable\n+                   \n+\n+    #Enviar arp request\n+    def send_arp_request(self, msg, pkt_ipv4):\n+        dpid = msg.datapath.id\n+        out_port = self.ip_to_port[dpid][pkt_ipv4.dst]\n+        src_mac = self.router_ports[msg.datapath.id][out_port]\n+        src_ip = self.router_ports_to_ip[dpid][out_port]\n+\n+\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\n+                                           dst='ff:ff:ff:ff:ff:ff',\n+                                           src=src_mac))\n+        pkt.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\n+                                 src_mac=src_mac,\n+                                 src_ip=src_ip,\n+                                 dst_mac='ff:ff:ff:ff:ff:ff',\n+                                 dst_ip=pkt_ipv4.dst))\n+\n+        self.send_packet(msg.datapath,out_port,pkt)\n+\n+        self.logger.info(\"\\nRouter %s sending ARP Request from port %s to learn MAC of %s\", msg.datapath.id, out_port, pkt_ipv4.dst)\n+\n+    #Enviar pacote\n+    def send_packet(self, datapath, port, pkt):\n+        ofproto = datapath.ofproto\n+        parser = datapath.ofproto_parser\n+        pkt.serialize()\n+        data = pkt.data\n+        actions = [parser.OFPActionOutput(port=port)]\n+        out = parser.OFPPacketOut(datapath=datapath,\n+                                  buffer_id=ofproto.OFP_NO_BUFFER,\n+                                  in_port=ofproto.OFPP_CONTROLLER,\n+                                  actions=actions,\n+                                  data=data)\n+        datapath.send_msg(out)\n+\n+    #Gerir arp requests\n+    def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\n+        #ARP packet handling.\n+        dpid = msg.datapath.id\n+\n+        if pkt_arp.dst_ip in [self.router_ports_to_ip][dpid].values() and pkt_arp.opcode == arp.ARP_REQUEST:\n+\n+            self.logger.info(\"\\nARP Request received by router %s from %s in port %s \", dpid, pkt_arp.src_ip, port)\n+\n+            port_mac = self.router_ports[dpid][port]\n+\n+            pkt = packet.Packet()\n+            pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\n+                                           dst=pkt_ethernet.src,\n+                                           src=port_mac))\n+            pkt.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n+                                 src_mac=port_mac,\n+                                 src_ip=pkt_arp.dst_ip,\n+                                 dst_mac=pkt_arp.src_mac,\n+                                 dst_ip=pkt_arp.src_ip))\n+            self.send_packet(msg.datapath, port, pkt)\n+\n+            self.logger.info(\"ARP Reply sent by router %s from port %s with MAC %s to %s\", dpid, port, port_mac, pkt_arp.src_ip)\n+\n+            return\n+        elif pkt_arp.dst_ip in [self.router_ports_to_ip][dpid].values() and pkt_arp.opcode == arp.ARP_REPLY:\n+            self.logger.info(\"\\nARP Reply received by router %s from %s with MAC %s\", dpid, pkt_arp.src_ip, pkt_arp.src_mac)\n+            self.ip_to_mac.setdefault(dpid, {})\n+            self.ip_to_mac[dpid][pkt_arp.src_ip] = pkt_arp.src_mac\n+\n+            for m in self.packet_queue[pkt_arp.src_ip]:\n+                dpid = m.datapath.id        \n+                pkt = packet.Packet(m.data)\n+                pkt_eth = pkt.get_protocol(ethernet.ethernet)\n+                pkt_v4 = pkt.get_protocol(ipv4.ipv4)\n+                out_port = self.ip_to_port[dpid][pkt_arp.src_ip]\n+                pkt_eth.src = self.router_ports[dpid][out_port]\n+                pkt_eth.dst = self.ip_to_mac[dpid][pkt_arp.src_ip]\n+                self.send_packet(msg.datapath,out_port,pkt)\n+                self.logger.info(\"Router %s sent queued packet from %s to %s\", dpid, pkt_v4.src, pkt_v4.dst)\n+\n+  \n+            #cycle through all packets to this ip and forward them\n+            return\n+        else:\n+            self.logger.info(\"\\nARP Packet dropped router %s, %s not an interface ip\", dpid, pkt_arp.dst_ip)\n+            \n+            #Any other case pass\n+            return\n+\n+\n+    def handle_icmp(self, msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp):\n+        # Send ICMP echo reply.\n+\n+        dpid = msg.datapath.id\n+        src_ip = pkt_ipv4.src\n+        self.logger.info('\\nICMP echo request received by router %s port %s from %s to %s.', dpid, port, src_ip, pkt_ipv4.dst)\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\n+                                           dst=pkt_ethernet.src,\n+                                           src=self.router_ports[dpid][port]))\n+        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\n+                                   src=self.router_ports_to_ip[dpid][port],\n+                                   proto=pkt_ipv4.proto))\n+        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\n+                                   code=icmp.ICMP_ECHO_REPLY_CODE,\n+                                   csum=0,\n+                                   data=pkt_icmp.data))\n+        self.send_packet(msg.datapath, port, pkt)\n+        self.logger.info('Send ICMP echo reply to [%s].', src_ip)\n+        \n+        match = parser.OFPMatch(in_port = port,\n+                                eth_type=0x0800,\n+                                ip_proto=pkt_ipv4.proto,\n+                                ipv4_src=pkt_ipv4.src,\n+                                ipv4_dst=pkt_ipv4.dst)\n+        \n+        #Inversao de endereços IPv4 e MAC para resopnder, e o tipo de código de ICMP alterados para reply.\n+        set_csum = parser.OFPActionSetField(ipv4_csum=0)\n+        set_eth_src = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n+        set_eth_dst = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n+        set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\n+        set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\n+        set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\n+        set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\n+        actions = [set_csum, set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\n+        \n+        self.add_flow(msg.datapath, 2, match, actions)\n+        out = msg.ofproto_parser.OFPPacketOut(datapath=msg.datapath,\n+                                              buffer_id=0xffffffff,\n+                                              in_port=msg.ofproto.OFPP_CONTROLLER,\n+                                              actions=actions,\n+                                              data=packet)\n+        msg.datapath.send_msg(out)\n+        \n+        \n+        self.logger.info(\"Entrada na flow table adicionada!\")\n+        \n+        \n+    def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\n+        dpid = msg.datapath.id\n+        port_mac = self.router_ports[msg.datapath.id][port]\n+\n+        offset = ethernet.ethernet._MIN_LEN\n+        end_of_data = offset + len(pkt_ipv4) + 128\n+        ip_datagram = bytearray()\n+        ip_datagram += msg.data[offset:end_of_data]\n+        data_len = int(len(ip_datagram) / 4)\n+        length_modulus = int(len(ip_datagram) % 4)\n+        if length_modulus:\n+            data_len += 1\n+            ip_datagram += bytearray([0] * (4 - length_modulus))\n+\n+        icmp_data = icmp.dest_unreach(data_len=data_len, data=ip_datagram)\n+\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\n+                                            dst=pkt_ethernet.src,\n+                                            src=port_mac))\n+        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\n+                                    src=self.router_ports_to_ip[dpid][port],\n+                                    proto=pkt_ipv4.proto))\n+        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_DEST_UNREACH,\n+                                    code=icmp.ICMP_HOST_UNREACH_CODE,\n+                                    csum=0,\n+                                    data=icmp_data))\n+        self.send_packet(msg.datapath, port, pkt)\n+\n+        self.logger.info(\"Router %s sending ICMP Destination Unreachable to %s\", msg.datapath.id, pkt_ipv4.src)\n+\n"
                },
                {
                    "date": 1655608350991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,8 +140,10 @@\n             self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n             return\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n+            print(self.router_ports_to_ip[dpid])\n+            print(self.router_ports_to_ip[dpid].values())\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608356308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,8 +142,9 @@\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n             print(self.router_ports_to_ip[dpid])\n             print(self.router_ports_to_ip[dpid].values())\n+            input(\"STOP\")\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608390727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,9 +142,9 @@\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n             print(self.router_ports_to_ip[dpid])\n             print(self.router_ports_to_ip[dpid].values())\n-            input(\"STOP\")\n+            time.sleep(100)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608403506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n from ryu.lib.packet import packet_base\n from ryu.lib.packet import tcp\n from ryu.lib.packet import udp\n from ryu.ofproto import ether\n-\n+import time\n ETHERNET = ethernet.ethernet.__name__\n IPV4 = ipv4.ipv4.__name__\n ARP = arp.arp.__name__\n ICMP = icmp.icmp.__name__\n"
                },
                {
                    "date": 1655608470304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,11 +140,8 @@\n             self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n             return\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n-            print(self.router_ports_to_ip[dpid])\n-            print(self.router_ports_to_ip[dpid].values())\n-            time.sleep(100)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608555714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,8 +140,9 @@\n             self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n             return\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n+            print(self.router.ports_to_ip)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608569128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,11 @@\n             self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n             return\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n-            print(self.router.ports_to_ip)\n+            print(dpid)\n+            print(type(dpid))\n+            print(self.router.ports_to_ip[dpid])\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608618621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,9 +142,10 @@\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n             print(dpid)\n             print(type(dpid))\n-            print(self.router.ports_to_ip[dpid])\n+            print(self.router_ports_to_ip[dpid])\n+            time.sleep(100)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608650299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,9 +143,8 @@\n         if pkt_ipv4:\n             print(dpid)\n             print(type(dpid))\n             print(self.router_ports_to_ip[dpid])\n-            time.sleep(100)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608665541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,9 +142,10 @@\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n             print(dpid)\n             print(type(dpid))\n-            print(self.router_ports_to_ip[dpid])\n+            print(self.router_ports_to_ip[dpid].values())\n+            time.sleep(100)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655608698387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,9 +143,8 @@\n         if pkt_ipv4:\n             print(dpid)\n             print(type(dpid))\n             print(self.router_ports_to_ip[dpid].values())\n-            time.sleep(100)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655609637463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,12 +44,14 @@\n         super(SwitchL3, self).__init__(*args, **kwargs)\n         self.ip_to_mac = {}\n         self.ip_to_mac = {}\n         self.ip_to_port = {  \n-                          4:  {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1},\n-                          5 : {'10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2},\n-                          6 : {'10.0.3.2': 3, '10.0.3.3' : 3, '10.0.3.4' : 3}\n-                          }\n+                            1:{'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1, '20.0.0.253' : 2, '30.0.0.253':3},\n+                            2:{'10.0.2.2' : 1, '10.0.2.3' : 1, '10.0.2.4' : 1, '20.0.0.254' : 2, '40.0.0.253':3},\n+                            3:{'10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3, '30.0.0.253' : 2, '40.0.0.253':3}\n+                        }\n+\n+                          \n     \n         self.router_ports = {}\n         self.router_ports_to_ip = {\n                                     1 :{1:'10.0.1.1', 2:'20.0.0.253', 3:'30.0.0.253'},\n"
                },
                {
                    "date": 1655609718985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,17 +49,14 @@\n                             2:{'10.0.2.2' : 1, '10.0.2.3' : 1, '10.0.2.4' : 1, '20.0.0.254' : 2, '40.0.0.253':3},\n                             3:{'10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3, '30.0.0.253' : 2, '40.0.0.253':3}\n                         }\n \n-                          \n-    \n         self.router_ports = {}\n         self.router_ports_to_ip = {\n                                     1 :{1:'10.0.1.1', 2:'20.0.0.253', 3:'30.0.0.253'},\n                                     2 :{1:'10.0.2.1', 2:'20.0.0.254', 3:'40.0.0.253'}, \n                                     3 :{1:'10.0.3.1', 2:'30.0.0.254', 3:'40.0.0.254'}\n                                   }\n-        \n         self.packet_queue = {}\n  \n         \n \n@@ -145,8 +142,9 @@\n         if pkt_ipv4:\n             print(dpid)\n             print(type(dpid))\n             print(self.router_ports_to_ip[dpid].values())\n+            time.sleep(100)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655609755043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,9 +142,9 @@\n         if pkt_ipv4:\n             print(dpid)\n             print(type(dpid))\n             print(self.router_ports_to_ip[dpid].values())\n-            time.sleep(100)\n+            time.sleep(2)\n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                },
                {
                    "date": 1655610077818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,12 +139,9 @@\n             self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n             return\n         pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n         if pkt_ipv4:\n-            print(dpid)\n-            print(type(dpid))\n-            print(self.router_ports_to_ip[dpid].values())\n-            time.sleep(2)\n+       \n             if pkt_ipv4.dst in self.router_ports_to_ip[dpid].values():\n                 pkt_icmp = pkt.get_protocol(icmp.icmp)\n                 if pkt_icmp:\n                     self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n"
                }
            ],
            "date": 1655562747406,
            "name": "Commit-0",
            "content": "from email import parser\r\nfrom ryu.base import app_manager\r\nfrom ryu.controller import ofp_event\r\nfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\r\nfrom ryu.controller.handler import set_ev_cls\r\nfrom ryu.ofproto import ofproto_v1_3\r\nfrom ryu.lib.packet import packet\r\nfrom ryu.lib.packet import ether_types\r\nfrom ryu.lib.packet import packet_base\r\nfrom ryu.lib.packet import ethernet\r\nfrom ryu.lib.packet import arp\r\nfrom ryu.lib.packet import ethernet\r\nfrom ryu.lib.packet import icmp\r\nfrom ryu.lib.packet import ipv4\r\nfrom ryu.lib.packet import packet\r\nfrom ryu.lib.packet import packet_base\r\nfrom ryu.lib.packet import tcp\r\nfrom ryu.lib.packet import udp\r\nfrom ryu.ofproto import ether\r\n\r\nETHERNET = ethernet.ethernet.__name__\r\nIPV4 = ipv4.ipv4.__name__\r\nARP = arp.arp.__name__\r\nICMP = icmp.icmp.__name__\r\nTCP = tcp.tcp.__name__\r\nUDP = udp.udp.__name__\r\n\r\n\r\n\r\n\r\nclass SwitchL3(app_manager.RyuApp):\r\n    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\r\n\r\n    \"\"\"Contrutor para a classe com as seguintes tabelas:\r\n        - ip_to_mac: dicionario de ip para mac\r\n        - ip_to_port: dicionario de ip para porta (L3)\r\n        - router_ports: dicionario de porta para ip \r\n        - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\r\n        - packet_queue: dicionario fila de pacotes arp\r\n    \"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super(SwitchL3, self).__init__(*args, **kwargs)\r\n        self.ip_to_mac = {}\r\n        self.ip_to_port = {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1,\r\n                           '10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2,\r\n                           '10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3,}\r\n        self.router_ports = {}\r\n        self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\r\n        \r\n        self.packet_queue = {}\r\n        \r\n        self.routers = {}\r\n        self.routes = {} # Rotas aprendidas para cada um dos routers\r\n        self.updates = {} # Updates na tabela \r\n        self.groupID = {} # Identificadores para cada dispositivo\r\n        \r\n        \r\n\r\n\r\n    \"\"\"\r\n    Função responsável pelo evento correspondente ao ennvio das funcionaliades presentes no switch para o controlado\r\n    \"\"\"\r\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\r\n    def switch_features_handler(self, ev):\r\n        datapath = ev.msg.datapath\r\n        ofproto = datapath.ofproto\r\n        parser = datapath.ofproto_parser\r\n\r\n        match = parser.OFPMatch()\r\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]\r\n\r\n        self.add_flow(datapath, 0, match, actions)\r\n\r\n        match = parser.OFPMatch(eth_type = ether_types.ETH_TYPE_IPV6)\r\n        actions = []\r\n\r\n        self.add_flow(datapath, 1, match, actions)\r\n        self.port_desc(datapath)\r\n\r\n    #Utility Function\r\n    def port_desc(self, datapath):\r\n        ofparser = datapath.ofproto_parser\r\n\r\n        req = ofparser.OFPPortDescStatsRequest(datapath,0)\r\n        datapath.send_msg(req)\r\n\r\n    #Utility Function\r\n    @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\r\n    def port_desc_stats_reply_handle(self,ev):\r\n\r\n        dpid = ev.msg.datapath.id\r\n        self.router_ports.setdefault(dpid, {})\r\n        for p in ev.msg.body:\r\n            self.router_ports[dpid].update({ p.port_no: p.hw_addr})\r\n        \r\n        print(\"L3 Switches Conectado dpid:\",dpid)\r\n        for p in self.router_ports[dpid].keys():\r\n            if p < 10:\r\n                print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\r\n                print(\"Cada Port Corresponde a uma subnet\")\r\n        print(\"\\n\")\r\n\r\n    #Adcionar flows\r\n    def add_flow(self, datapath, priority, match, actions, buffer_id=None):\r\n        ofproto = datapath.ofproto\r\n        parser = datapath.ofproto_parser\r\n\r\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\r\n                                             actions)]\r\n        if buffer_id:\r\n            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\r\n                                    priority=priority, match=match,\r\n                                    instructions=inst)\r\n        else:\r\n            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\r\n                                    match=match, instructions=inst)\r\n        datapath.send_msg(mod)\r\n \r\n    #Gestão de pacotes\r\n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\r\n    def packet_in_handler(self, ev):\r\n        msg = ev.msg\r\n        dpid = msg.datapath.id        \r\n        port = msg.match['in_port']\r\n        pkt = packet.Packet(msg.data)\r\n\r\n        #self.logger.info(\"\\npacket-in %s\" % (pkt,))\r\n\r\n        pkt_ethernet = pkt.get_protocol(ethernet.ethernet)\r\n        if not pkt_ethernet:\r\n            return\r\n        pkt_arp = pkt.get_protocol(arp.arp)\r\n        if pkt_arp:\r\n            #ARP handling\r\n            self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\r\n            return\r\n        pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\r\n        if pkt_ipv4:\r\n            if pkt_ipv4.dst in self.router_ports_to_ip.values():\r\n                pkt_icmp = pkt.get_protocol(icmp.icmp)\r\n                if pkt_icmp:\r\n                    self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\r\n                    return\r\n            else:\r\n                #Static routing handling\r\n                if pkt_ipv4.dst in self.ip_to_port.keys():\r\n                    self.logger.info(\"\\nPacket received by router %s from %s to %s \", dpid, pkt_ipv4.src, pkt_ipv4.dst)\r\n                    self.ip_to_mac.setdefault(dpid, {})\r\n                    if pkt_ipv4.dst in self.ip_to_mac[dpid].keys():\r\n                        out_port = self.ip_to_port[pkt_ipv4.dst]\r\n                        pkt_ethernet.src = self.router_ports[dpid][out_port]\r\n                        pkt_ethernet.dst = self.ip_to_mac[dpid][pkt_ipv4.dst]\r\n                        self.send_packet(msg.datapath,out_port,pkt)\r\n                        return\r\n\r\n                    else:\r\n                        #Send ARP Request\r\n                        self.packet_queue.setdefault(pkt_ipv4.dst,[])\r\n                        self.packet_queue[pkt_ipv4.dst].append(msg)\r\n                        self.logger.info(\"\\nRouter %s doesn't know MAC of %s adding packet to queue\", dpid, pkt_ipv4.dst)\r\n                        self.send_arp_request(msg, pkt_ipv4)\r\n                        return\r\n\r\n                else:\r\n                    self.logger.info(\"\\nPacket received by router %s from %s to %s (unknown destination)\", dpid, pkt_ipv4.src, pkt_ipv4.dst)\r\n                    self.send_icmp_unreachable(msg, port, pkt_ethernet, pkt_ipv4)\r\n                    #Send ICMP network unreachable\r\n                   \r\n\r\n    #Enviar arp request\r\n    def send_arp_request(self, msg, pkt_ipv4):\r\n        out_port = self.ip_to_port[pkt_ipv4.dst]\r\n        src_mac = self.router_ports[msg.datapath.id][out_port]\r\n        src_ip = self.router_ports_to_ip[out_port]\r\n\r\n\r\n        pkt = packet.Packet()\r\n        pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\r\n                                           dst='ff:ff:ff:ff:ff:ff',\r\n                                           src=src_mac))\r\n        pkt.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\r\n                                 src_mac=src_mac,\r\n                                 src_ip=src_ip,\r\n                                 dst_mac='ff:ff:ff:ff:ff:ff',\r\n                                 dst_ip=pkt_ipv4.dst))\r\n\r\n        self.send_packet(msg.datapath,out_port,pkt)\r\n\r\n        self.logger.info(\"\\nRouter %s sending ARP Request from port %s to learn MAC of %s\", msg.datapath.id, out_port, pkt_ipv4.dst)\r\n\r\n    #Enviar pacote\r\n    def send_packet(self, datapath, port, pkt):\r\n        ofproto = datapath.ofproto\r\n        parser = datapath.ofproto_parser\r\n        pkt.serialize()\r\n        data = pkt.data\r\n        actions = [parser.OFPActionOutput(port=port)]\r\n        out = parser.OFPPacketOut(datapath=datapath,\r\n                                  buffer_id=ofproto.OFP_NO_BUFFER,\r\n                                  in_port=ofproto.OFPP_CONTROLLER,\r\n                                  actions=actions,\r\n                                  data=data)\r\n        datapath.send_msg(out)\r\n\r\n    #Gerir arp requests\r\n    def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\r\n        #ARP packet handling.\r\n        dpid = msg.datapath.id\r\n\r\n        if pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REQUEST:\r\n\r\n            self.logger.info(\"\\nARP Request received by router %s from %s in port %s \", dpid, pkt_arp.src_ip, port)\r\n\r\n            port_mac = self.router_ports[dpid][port]\r\n\r\n            pkt = packet.Packet()\r\n            pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\r\n                                           dst=pkt_ethernet.src,\r\n                                           src=port_mac))\r\n            pkt.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\r\n                                 src_mac=port_mac,\r\n                                 src_ip=pkt_arp.dst_ip,\r\n                                 dst_mac=pkt_arp.src_mac,\r\n                                 dst_ip=pkt_arp.src_ip))\r\n            self.send_packet(msg.datapath, port, pkt)\r\n\r\n            self.logger.info(\"ARP Reply sent by router %s from port %s with MAC %s to %s\", dpid, port, port_mac, pkt_arp.src_ip)\r\n\r\n            return\r\n        elif pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REPLY:\r\n            self.logger.info(\"\\nARP Reply received by router %s from %s with MAC %s\", dpid, pkt_arp.src_ip, pkt_arp.src_mac)\r\n            self.ip_to_mac.setdefault(dpid, {})\r\n            self.ip_to_mac[dpid][pkt_arp.src_ip] = pkt_arp.src_mac\r\n\r\n            for m in self.packet_queue[pkt_arp.src_ip]:\r\n                dpid = m.datapath.id        \r\n                pkt = packet.Packet(m.data)\r\n                pkt_eth = pkt.get_protocol(ethernet.ethernet)\r\n                pkt_v4 = pkt.get_protocol(ipv4.ipv4)\r\n                out_port = self.ip_to_port[pkt_arp.src_ip]\r\n                pkt_eth.src = self.router_ports[dpid][out_port]\r\n                pkt_eth.dst = self.ip_to_mac[dpid][pkt_arp.src_ip]\r\n                self.send_packet(msg.datapath,out_port,pkt)\r\n                self.logger.info(\"Router %s sent queued packet from %s to %s\", dpid, pkt_v4.src, pkt_v4.dst)\r\n\r\n  \r\n            #cycle through all packets to this ip and forward them\r\n            return\r\n        else:\r\n            self.logger.info(\"\\nARP Packet dropped router %s, %s not an interface ip\", dpid, pkt_arp.dst_ip)\r\n            \r\n            #Any other case pass\r\n            return\r\n\r\n\r\n    def handle_icmp(self, msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp):\r\n        # Send ICMP echo reply.\r\n\r\n        dpid = msg.datapath.id\r\n        src_ip = pkt_ipv4.src\r\n        self.logger.info('\\nICMP echo request received by router %s port %s from %s to %s.', dpid, port, src_ip, pkt_ipv4.dst)\r\n        pkt = packet.Packet()\r\n        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n                                           dst=pkt_ethernet.src,\r\n                                           src=self.router_ports[dpid][port]))\r\n        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n                                   src=self.router_ports_to_ip[port],\r\n                                   proto=pkt_ipv4.proto))\r\n        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\r\n                                   code=icmp.ICMP_ECHO_REPLY_CODE,\r\n                                   csum=0,\r\n                                   data=pkt_icmp.data))\r\n        self.send_packet(msg.datapath, port, pkt)\r\n        self.logger.info('Send ICMP echo reply to [%s].', src_ip)\r\n        \r\n        match = parser.OFPMatch(in_port = port,\r\n                                eth_type=0x0800,\r\n                                ip_proto=pkt_ipv4.proto,\r\n                                ipv4_src=pkt_ipv4.src,\r\n                                ipv4_dst=pkt_ipv4.dst)\r\n        \r\n        #Inversao de endereços IPv4 e MAC para resopnder, e o tipo de código de ICMP alterados para reply.\r\n        set_csum = parser.OFPActionSetField(ipv4_csum=0)\r\n        set_eth_src = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\r\n        set_eth_dst = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\r\n        set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\r\n        set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\r\n        set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\r\n        set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\r\n        actions = [set_csum, set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\r\n        \r\n        self.add_flow(msg.datapath, 2, match, actions)\r\n        out = msg.ofproto_parser.OFPPacketOut(datapath=msg.datapath,\r\n                                              buffer_id=0xffffffff,\r\n                                              in_port=msg.ofproto.OFPP_CONTROLLER,\r\n                                              actions=actions,\r\n                                              data=packet)\r\n        msg.datapath.send_msg(out)\r\n        \r\n        \r\n        self.logger.info(\"Entrada na flow table adicionada!\")\r\n        \r\n        \r\n    def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\r\n        port_mac = self.router_ports[msg.datapath.id][port]\r\n\r\n        offset = ethernet.ethernet._MIN_LEN\r\n        end_of_data = offset + len(pkt_ipv4) + 128\r\n        ip_datagram = bytearray()\r\n        ip_datagram += msg.data[offset:end_of_data]\r\n        data_len = int(len(ip_datagram) / 4)\r\n        length_modulus = int(len(ip_datagram) % 4)\r\n        if length_modulus:\r\n            data_len += 1\r\n            ip_datagram += bytearray([0] * (4 - length_modulus))\r\n\r\n        icmp_data = icmp.dest_unreach(data_len=data_len, data=ip_datagram)\r\n\r\n        pkt = packet.Packet()\r\n        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n                                            dst=pkt_ethernet.src,\r\n                                            src=port_mac))\r\n        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n                                    src=self.router_ports_to_ip[port],\r\n                                    proto=pkt_ipv4.proto))\r\n        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_DEST_UNREACH,\r\n                                    code=icmp.ICMP_HOST_UNREACH_CODE,\r\n                                    csum=0,\r\n                                    data=icmp_data))\r\n        self.send_packet(msg.datapath, port, pkt)\r\n\r\n        self.logger.info(\"Router %s sending ICMP Destination Unreachable to %s\", msg.datapath.id, pkt_ipv4.src)\r\n\r\n"
        }
    ]
}
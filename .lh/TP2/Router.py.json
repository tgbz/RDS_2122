{
    "sourceFile": "TP2/Router.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1655562747406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1655567367240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,12 @@\n UDP = udp.udp.__name__\r\n \r\n \r\n \r\n+interface_port_to_ip = {1: {1: '191.0.0.254', 2: '12.0.0.253', 3: '13.0.0.253'},\r\n+                        2: {1: '192.0.0.254', 2: '12.0.0.254', 3: '23.0.0.253'},\r\n+                        3: {1: '193.0.0.254', 2: '13.0.0.254', 3: '23.0.0.254'}\r\n+                        }\r\n \r\n class SwitchL3(app_manager.RyuApp):\r\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\r\n \r\n@@ -38,14 +42,15 @@\n         - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\r\n         - packet_queue: dicionario fila de pacotes arp\r\n     \"\"\"\r\n \r\n+\r\n     def __init__(self, *args, **kwargs):\r\n         super(SwitchL3, self).__init__(*args, **kwargs)\r\n         self.ip_to_mac = {}\r\n-        self.ip_to_port = {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1,\r\n-                           '10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2,\r\n-                           '10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3,}\r\n+        self.ip_to_port = {'10.0.1.2' : 1, '20.0.0.253' : 1, '30.0.0.253' : 1,\r\n+                           '10.0.2.2' : 2, '20.0.0.254' : 2, '40.0.0.253' : 2,\r\n+                           '10.0.3.2' : 3, '30.0.0.254' : 3, '40.0.0.254' : 3,}\r\n         self.router_ports = {}\r\n         self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\r\n         \r\n         self.packet_queue = {}\r\n"
                }
            ],
            "date": 1655562747406,
            "name": "Commit-0",
            "content": "from email import parser\r\nfrom ryu.base import app_manager\r\nfrom ryu.controller import ofp_event\r\nfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\r\nfrom ryu.controller.handler import set_ev_cls\r\nfrom ryu.ofproto import ofproto_v1_3\r\nfrom ryu.lib.packet import packet\r\nfrom ryu.lib.packet import ether_types\r\nfrom ryu.lib.packet import packet_base\r\nfrom ryu.lib.packet import ethernet\r\nfrom ryu.lib.packet import arp\r\nfrom ryu.lib.packet import ethernet\r\nfrom ryu.lib.packet import icmp\r\nfrom ryu.lib.packet import ipv4\r\nfrom ryu.lib.packet import packet\r\nfrom ryu.lib.packet import packet_base\r\nfrom ryu.lib.packet import tcp\r\nfrom ryu.lib.packet import udp\r\nfrom ryu.ofproto import ether\r\n\r\nETHERNET = ethernet.ethernet.__name__\r\nIPV4 = ipv4.ipv4.__name__\r\nARP = arp.arp.__name__\r\nICMP = icmp.icmp.__name__\r\nTCP = tcp.tcp.__name__\r\nUDP = udp.udp.__name__\r\n\r\n\r\n\r\n\r\nclass SwitchL3(app_manager.RyuApp):\r\n    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\r\n\r\n    \"\"\"Contrutor para a classe com as seguintes tabelas:\r\n        - ip_to_mac: dicionario de ip para mac\r\n        - ip_to_port: dicionario de ip para porta (L3)\r\n        - router_ports: dicionario de porta para ip \r\n        - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\r\n        - packet_queue: dicionario fila de pacotes arp\r\n    \"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super(SwitchL3, self).__init__(*args, **kwargs)\r\n        self.ip_to_mac = {}\r\n        self.ip_to_port = {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1,\r\n                           '10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2,\r\n                           '10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3,}\r\n        self.router_ports = {}\r\n        self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\r\n        \r\n        self.packet_queue = {}\r\n        \r\n        self.routers = {}\r\n        self.routes = {} # Rotas aprendidas para cada um dos routers\r\n        self.updates = {} # Updates na tabela \r\n        self.groupID = {} # Identificadores para cada dispositivo\r\n        \r\n        \r\n\r\n\r\n    \"\"\"\r\n    Função responsável pelo evento correspondente ao ennvio das funcionaliades presentes no switch para o controlado\r\n    \"\"\"\r\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\r\n    def switch_features_handler(self, ev):\r\n        datapath = ev.msg.datapath\r\n        ofproto = datapath.ofproto\r\n        parser = datapath.ofproto_parser\r\n\r\n        match = parser.OFPMatch()\r\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]\r\n\r\n        self.add_flow(datapath, 0, match, actions)\r\n\r\n        match = parser.OFPMatch(eth_type = ether_types.ETH_TYPE_IPV6)\r\n        actions = []\r\n\r\n        self.add_flow(datapath, 1, match, actions)\r\n        self.port_desc(datapath)\r\n\r\n    #Utility Function\r\n    def port_desc(self, datapath):\r\n        ofparser = datapath.ofproto_parser\r\n\r\n        req = ofparser.OFPPortDescStatsRequest(datapath,0)\r\n        datapath.send_msg(req)\r\n\r\n    #Utility Function\r\n    @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\r\n    def port_desc_stats_reply_handle(self,ev):\r\n\r\n        dpid = ev.msg.datapath.id\r\n        self.router_ports.setdefault(dpid, {})\r\n        for p in ev.msg.body:\r\n            self.router_ports[dpid].update({ p.port_no: p.hw_addr})\r\n        \r\n        print(\"L3 Switches Conectado dpid:\",dpid)\r\n        for p in self.router_ports[dpid].keys():\r\n            if p < 10:\r\n                print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\r\n                print(\"Cada Port Corresponde a uma subnet\")\r\n        print(\"\\n\")\r\n\r\n    #Adcionar flows\r\n    def add_flow(self, datapath, priority, match, actions, buffer_id=None):\r\n        ofproto = datapath.ofproto\r\n        parser = datapath.ofproto_parser\r\n\r\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\r\n                                             actions)]\r\n        if buffer_id:\r\n            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\r\n                                    priority=priority, match=match,\r\n                                    instructions=inst)\r\n        else:\r\n            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\r\n                                    match=match, instructions=inst)\r\n        datapath.send_msg(mod)\r\n \r\n    #Gestão de pacotes\r\n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\r\n    def packet_in_handler(self, ev):\r\n        msg = ev.msg\r\n        dpid = msg.datapath.id        \r\n        port = msg.match['in_port']\r\n        pkt = packet.Packet(msg.data)\r\n\r\n        #self.logger.info(\"\\npacket-in %s\" % (pkt,))\r\n\r\n        pkt_ethernet = pkt.get_protocol(ethernet.ethernet)\r\n        if not pkt_ethernet:\r\n            return\r\n        pkt_arp = pkt.get_protocol(arp.arp)\r\n        if pkt_arp:\r\n            #ARP handling\r\n            self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\r\n            return\r\n        pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\r\n        if pkt_ipv4:\r\n            if pkt_ipv4.dst in self.router_ports_to_ip.values():\r\n                pkt_icmp = pkt.get_protocol(icmp.icmp)\r\n                if pkt_icmp:\r\n                    self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\r\n                    return\r\n            else:\r\n                #Static routing handling\r\n                if pkt_ipv4.dst in self.ip_to_port.keys():\r\n                    self.logger.info(\"\\nPacket received by router %s from %s to %s \", dpid, pkt_ipv4.src, pkt_ipv4.dst)\r\n                    self.ip_to_mac.setdefault(dpid, {})\r\n                    if pkt_ipv4.dst in self.ip_to_mac[dpid].keys():\r\n                        out_port = self.ip_to_port[pkt_ipv4.dst]\r\n                        pkt_ethernet.src = self.router_ports[dpid][out_port]\r\n                        pkt_ethernet.dst = self.ip_to_mac[dpid][pkt_ipv4.dst]\r\n                        self.send_packet(msg.datapath,out_port,pkt)\r\n                        return\r\n\r\n                    else:\r\n                        #Send ARP Request\r\n                        self.packet_queue.setdefault(pkt_ipv4.dst,[])\r\n                        self.packet_queue[pkt_ipv4.dst].append(msg)\r\n                        self.logger.info(\"\\nRouter %s doesn't know MAC of %s adding packet to queue\", dpid, pkt_ipv4.dst)\r\n                        self.send_arp_request(msg, pkt_ipv4)\r\n                        return\r\n\r\n                else:\r\n                    self.logger.info(\"\\nPacket received by router %s from %s to %s (unknown destination)\", dpid, pkt_ipv4.src, pkt_ipv4.dst)\r\n                    self.send_icmp_unreachable(msg, port, pkt_ethernet, pkt_ipv4)\r\n                    #Send ICMP network unreachable\r\n                   \r\n\r\n    #Enviar arp request\r\n    def send_arp_request(self, msg, pkt_ipv4):\r\n        out_port = self.ip_to_port[pkt_ipv4.dst]\r\n        src_mac = self.router_ports[msg.datapath.id][out_port]\r\n        src_ip = self.router_ports_to_ip[out_port]\r\n\r\n\r\n        pkt = packet.Packet()\r\n        pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\r\n                                           dst='ff:ff:ff:ff:ff:ff',\r\n                                           src=src_mac))\r\n        pkt.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\r\n                                 src_mac=src_mac,\r\n                                 src_ip=src_ip,\r\n                                 dst_mac='ff:ff:ff:ff:ff:ff',\r\n                                 dst_ip=pkt_ipv4.dst))\r\n\r\n        self.send_packet(msg.datapath,out_port,pkt)\r\n\r\n        self.logger.info(\"\\nRouter %s sending ARP Request from port %s to learn MAC of %s\", msg.datapath.id, out_port, pkt_ipv4.dst)\r\n\r\n    #Enviar pacote\r\n    def send_packet(self, datapath, port, pkt):\r\n        ofproto = datapath.ofproto\r\n        parser = datapath.ofproto_parser\r\n        pkt.serialize()\r\n        data = pkt.data\r\n        actions = [parser.OFPActionOutput(port=port)]\r\n        out = parser.OFPPacketOut(datapath=datapath,\r\n                                  buffer_id=ofproto.OFP_NO_BUFFER,\r\n                                  in_port=ofproto.OFPP_CONTROLLER,\r\n                                  actions=actions,\r\n                                  data=data)\r\n        datapath.send_msg(out)\r\n\r\n    #Gerir arp requests\r\n    def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\r\n        #ARP packet handling.\r\n        dpid = msg.datapath.id\r\n\r\n        if pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REQUEST:\r\n\r\n            self.logger.info(\"\\nARP Request received by router %s from %s in port %s \", dpid, pkt_arp.src_ip, port)\r\n\r\n            port_mac = self.router_ports[dpid][port]\r\n\r\n            pkt = packet.Packet()\r\n            pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\r\n                                           dst=pkt_ethernet.src,\r\n                                           src=port_mac))\r\n            pkt.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\r\n                                 src_mac=port_mac,\r\n                                 src_ip=pkt_arp.dst_ip,\r\n                                 dst_mac=pkt_arp.src_mac,\r\n                                 dst_ip=pkt_arp.src_ip))\r\n            self.send_packet(msg.datapath, port, pkt)\r\n\r\n            self.logger.info(\"ARP Reply sent by router %s from port %s with MAC %s to %s\", dpid, port, port_mac, pkt_arp.src_ip)\r\n\r\n            return\r\n        elif pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REPLY:\r\n            self.logger.info(\"\\nARP Reply received by router %s from %s with MAC %s\", dpid, pkt_arp.src_ip, pkt_arp.src_mac)\r\n            self.ip_to_mac.setdefault(dpid, {})\r\n            self.ip_to_mac[dpid][pkt_arp.src_ip] = pkt_arp.src_mac\r\n\r\n            for m in self.packet_queue[pkt_arp.src_ip]:\r\n                dpid = m.datapath.id        \r\n                pkt = packet.Packet(m.data)\r\n                pkt_eth = pkt.get_protocol(ethernet.ethernet)\r\n                pkt_v4 = pkt.get_protocol(ipv4.ipv4)\r\n                out_port = self.ip_to_port[pkt_arp.src_ip]\r\n                pkt_eth.src = self.router_ports[dpid][out_port]\r\n                pkt_eth.dst = self.ip_to_mac[dpid][pkt_arp.src_ip]\r\n                self.send_packet(msg.datapath,out_port,pkt)\r\n                self.logger.info(\"Router %s sent queued packet from %s to %s\", dpid, pkt_v4.src, pkt_v4.dst)\r\n\r\n  \r\n            #cycle through all packets to this ip and forward them\r\n            return\r\n        else:\r\n            self.logger.info(\"\\nARP Packet dropped router %s, %s not an interface ip\", dpid, pkt_arp.dst_ip)\r\n            \r\n            #Any other case pass\r\n            return\r\n\r\n\r\n    def handle_icmp(self, msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp):\r\n        # Send ICMP echo reply.\r\n\r\n        dpid = msg.datapath.id\r\n        src_ip = pkt_ipv4.src\r\n        self.logger.info('\\nICMP echo request received by router %s port %s from %s to %s.', dpid, port, src_ip, pkt_ipv4.dst)\r\n        pkt = packet.Packet()\r\n        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n                                           dst=pkt_ethernet.src,\r\n                                           src=self.router_ports[dpid][port]))\r\n        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n                                   src=self.router_ports_to_ip[port],\r\n                                   proto=pkt_ipv4.proto))\r\n        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\r\n                                   code=icmp.ICMP_ECHO_REPLY_CODE,\r\n                                   csum=0,\r\n                                   data=pkt_icmp.data))\r\n        self.send_packet(msg.datapath, port, pkt)\r\n        self.logger.info('Send ICMP echo reply to [%s].', src_ip)\r\n        \r\n        match = parser.OFPMatch(in_port = port,\r\n                                eth_type=0x0800,\r\n                                ip_proto=pkt_ipv4.proto,\r\n                                ipv4_src=pkt_ipv4.src,\r\n                                ipv4_dst=pkt_ipv4.dst)\r\n        \r\n        #Inversao de endereços IPv4 e MAC para resopnder, e o tipo de código de ICMP alterados para reply.\r\n        set_csum = parser.OFPActionSetField(ipv4_csum=0)\r\n        set_eth_src = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\r\n        set_eth_dst = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\r\n        set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\r\n        set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\r\n        set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\r\n        set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\r\n        actions = [set_csum, set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\r\n        \r\n        self.add_flow(msg.datapath, 2, match, actions)\r\n        out = msg.ofproto_parser.OFPPacketOut(datapath=msg.datapath,\r\n                                              buffer_id=0xffffffff,\r\n                                              in_port=msg.ofproto.OFPP_CONTROLLER,\r\n                                              actions=actions,\r\n                                              data=packet)\r\n        msg.datapath.send_msg(out)\r\n        \r\n        \r\n        self.logger.info(\"Entrada na flow table adicionada!\")\r\n        \r\n        \r\n    def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\r\n        port_mac = self.router_ports[msg.datapath.id][port]\r\n\r\n        offset = ethernet.ethernet._MIN_LEN\r\n        end_of_data = offset + len(pkt_ipv4) + 128\r\n        ip_datagram = bytearray()\r\n        ip_datagram += msg.data[offset:end_of_data]\r\n        data_len = int(len(ip_datagram) / 4)\r\n        length_modulus = int(len(ip_datagram) % 4)\r\n        if length_modulus:\r\n            data_len += 1\r\n            ip_datagram += bytearray([0] * (4 - length_modulus))\r\n\r\n        icmp_data = icmp.dest_unreach(data_len=data_len, data=ip_datagram)\r\n\r\n        pkt = packet.Packet()\r\n        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\r\n                                            dst=pkt_ethernet.src,\r\n                                            src=port_mac))\r\n        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\r\n                                    src=self.router_ports_to_ip[port],\r\n                                    proto=pkt_ipv4.proto))\r\n        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_DEST_UNREACH,\r\n                                    code=icmp.ICMP_HOST_UNREACH_CODE,\r\n                                    csum=0,\r\n                                    data=icmp_data))\r\n        self.send_packet(msg.datapath, port, pkt)\r\n\r\n        self.logger.info(\"Router %s sending ICMP Destination Unreachable to %s\", msg.datapath.id, pkt_ipv4.src)\r\n\r\n"
        }
    ]
}
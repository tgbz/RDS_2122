{
    "sourceFile": "tuts/controller.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1652118708367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1652118708367,
            "name": "Commit-0",
            "content": "from ryu.base import app_manager\nfrom ryu.controller import ofp_event\nfrom ryu.controller.handler import CONFIG_DISPATCHER, DEAD_DISPATCHER\nfrom ryu.controller.handler import MAIN_DISPATCHER, HANDSHAKE_DISPATCHER\nfrom ryu.controller.handler import set_ev_cls\nfrom ryu.ofproto import ofproto_v1_3\nfrom ryu.ofproto import ether\nfrom ryu.lib.packet import packet\nfrom ryu.lib.packet import ethernet\nfrom ryu.lib.packet import arp\nfrom ryu.lib.packet import ipv4\nfrom ryu.lib.packet import ipv6\nfrom ryu import utils\n\n\nclass MULTIPATH_13(app_manager.RyuApp):\n    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n\n    def __init__(self, *args, **kwargs):\n        super(MULTIPATH_13, self).__init__(*args, **kwargs)\n        self.mac_to_port = {}\n        self.datapaths = {}\n        self.FLAGS = True\n\n    @set_ev_cls(\n        ofp_event.EventOFPErrorMsg,\n        [HANDSHAKE_DISPATCHER, CONFIG_DISPATCHER, MAIN_DISPATCHER])\n    def error_msg_handler(self, ev):\n        msg = ev.msg\n        self.logger.debug('OFPErrorMsg received: type=0x%02x code=0x%02x '\n                          'message=%s', msg.type, msg.code,\n                          utils.hex_array(msg.data))\n\n    @set_ev_cls(ofp_event.EventOFPStateChange,\n                [MAIN_DISPATCHER, DEAD_DISPATCHER])\n    def _state_change_handler(self, ev):\n        datapath = ev.datapath\n        if ev.state == MAIN_DISPATCHER:\n            if not datapath.id in self.datapaths:\n                self.logger.debug('register datapath: %016x', datapath.id)\n                self.datapaths[datapath.id] = datapath\n        elif ev.state == DEAD_DISPATCHER:\n            if datapath.id in self.datapaths:\n                self.logger.debug('unregister datapath: %016x', datapath.id)\n                del self.datapaths[datapath.id]\n\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n    def switch_features_handler(self, ev):\n        datapath = ev.msg.datapath\n        dpid = datapath.id\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        # install table-miss flow entry\n        match = parser.OFPMatch()\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                          ofproto.OFPCML_NO_BUFFER)]\n        self.add_flow(datapath, 0, 0, match, actions)\n        self.logger.info(\"switch:%s connected\", dpid)\n\n    def add_flow(self, datapath, hard_timeout, priority, match, actions):\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                             actions)]\n\n        mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                hard_timeout=hard_timeout,\n                                match=match, instructions=inst)\n        datapath.send_msg(mod)\n\n    def _build_packet_out(self, datapath, buffer_id, src_port, dst_port, data):\n        actions = []\n        if dst_port:\n            actions.append(datapath.ofproto_parser.OFPActionOutput(dst_port))\n\n        msg_data = None\n        if buffer_id == datapath.ofproto.OFP_NO_BUFFER:\n            if data is None:\n                return None\n            msg_data = data\n\n        out = datapath.ofproto_parser.OFPPacketOut(\n            datapath=datapath, buffer_id=buffer_id,\n            data=msg_data, in_port=src_port, actions=actions)\n        return out\n\n    def send_packet_out(self, datapath, buffer_id, src_port, dst_port, data):\n        out = self._build_packet_out(datapath, buffer_id,\n                                     src_port, dst_port, data)\n        if out:\n            datapath.send_msg(out)\n\n    def flood(self, msg):\n        datapath = msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n        out = self._build_packet_out(datapath, ofproto.OFP_NO_BUFFER,\n                                     ofproto.OFPP_CONTROLLER,\n                                     ofproto.OFPP_FLOOD, msg.data)\n        datapath.send_msg(out)\n        self.logger.debug(\"Flooding msg\")\n\n    def arp_forwarding(self, msg, src_ip, dst_ip, eth_pkt):\n        datapath = msg.datapath\n        parser = datapath.ofproto_parser\n        in_port = msg.match['in_port']\n\n        out_port = self.mac_to_port[datapath.id].get(eth_pkt.dst)\n        if out_port is not None:\n            match = parser.OFPMatch(in_port=in_port, eth_dst=eth_pkt.dst,\n                                    eth_type=eth_pkt.ethertype)\n            actions = [parser.OFPActionOutput(out_port)]\n            self.add_flow(datapath, 0, 1, match, actions)\n            self.send_packet_out(datapath, msg.buffer_id, in_port,\n                                 out_port, msg.data)\n            self.logger.debug(\"Reply ARP to knew host\")\n        else:\n            self.flood(msg)\n\n    def mac_learning(self, dpid, src_mac, in_port):\n        self.mac_to_port.setdefault(dpid, {})\n        if src_mac in self.mac_to_port[dpid]:\n            if in_port != self.mac_to_port[dpid][src_mac]:\n                return False\n        else:\n            self.mac_to_port[dpid][src_mac] = in_port\n            return True\n\n    def send_group_mod(self, datapath,):\n        ofproto = datapath.ofproto\n        ofp_parser = datapath.ofproto_parser\n\n        port_1 = 3\n        queue_1 = ofp_parser.OFPActionSetQueue(0)\n        actions_1 = [queue_1, ofp_parser.OFPActionOutput(port_1)]\n\n        port_2 = 2\n        queue_2 = ofp_parser.OFPActionSetQueue(0)\n        actions_2 = [queue_2, ofp_parser.OFPActionOutput(port_2)]\n\n        weight_1 = 50\n        weight_2 = 50\n\n        watch_port = ofproto_v1_3.OFPP_ANY\n        watch_group = ofproto_v1_3.OFPQ_ALL\n\n        buckets = [\n            ofp_parser.OFPBucket(weight_1, watch_port, watch_group, actions_1),\n            ofp_parser.OFPBucket(weight_2, watch_port, watch_group, actions_2)]\n\n        group_id = 50\n        req = ofp_parser.OFPGroupMod(datapath, ofproto.OFPFC_ADD,\n                                     ofproto.OFPGT_SELECT, group_id, buckets)\n\n        datapath.send_msg(req)\n\n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n    def _packet_in_handler(self, ev):\n        msg = ev.msg\n        datapath = msg.datapath\n        dpid = datapath.id\n        parser = datapath.ofproto_parser\n        in_port = msg.match['in_port']\n\n        pkt = packet.Packet(msg.data)\n        eth = pkt.get_protocols(ethernet.ethernet)[0]\n        arp_pkt = pkt.get_protocol(arp.arp)\n        ip_pkt = pkt.get_protocol(ipv4.ipv4)\n\n        ip_pkt_6 = pkt.get_protocol(ipv6.ipv6)\n        if isinstance(ip_pkt_6, ipv6.ipv6):\n            actions = []\n            match = parser.OFPMatch(eth_type=ether.ETH_TYPE_IPV6)\n            self.add_flow(datapath, 0, 1, match, actions)\n            return\n\n        if isinstance(arp_pkt, arp.arp):\n            self.logger.debug(\"ARP processing\")\n            if self.mac_learning(dpid, eth.src, in_port) is False:\n                self.logger.debug(\"ARP packet enter in different ports\")\n                return\n\n            self.arp_forwarding(msg, arp_pkt.src_ip, arp_pkt.dst_ip, eth)\n\n        if isinstance(ip_pkt, ipv4.ipv4):\n            self.logger.debug(\"IPV4 processing\")\n            mac_to_port_table = self.mac_to_port.get(dpid)\n            if mac_to_port_table is None:\n                self.logger.info(\"Dpid is not in mac_to_port\")\n                return\n\n            out_port = None\n            if eth.dst in mac_to_port_table:\n                if dpid == 1 and in_port == 1:\n                    if self.FLAGS is True:\n                        self.send_group_mod(datapath)\n                        self.logger.info(\"send_group_mod\")\n                        self.FLAGS = False\n\n                    actions = [parser.OFPActionGroup(group_id=50)]\n                    match = parser.OFPMatch(in_port=in_port,\n                                            eth_type=eth.ethertype,\n                                            ipv4_src=ip_pkt.src)\n                    self.add_flow(datapath, 0, 3, match, actions)\n                    # asign output at 2\n                    self.send_packet_out(datapath, msg.buffer_id,\n                                         in_port, 2, msg.data)\n                else:\n                    #Normal flows\n                    out_port = mac_to_port_table[eth.dst]\n                    actions = [parser.OFPActionOutput(out_port)]\n                    match = parser.OFPMatch(in_port=in_port, eth_dst=eth.dst,\n                                            eth_type=eth.ethertype)\n                    self.add_flow(datapath, 0, 1, match, actions)\n                    self.send_packet_out(datapath, msg.buffer_id, in_port,\n                                         out_port, msg.data)\n            else:\n                if self.mac_learning(dpid, eth.src, in_port) is False:\n                    self.logger.debug(\"IPV4 packet enter in different ports\")\n                    return\n                else:\n                    self.flood(msg)\n"
        }
    ]
}
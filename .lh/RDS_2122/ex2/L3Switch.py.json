{
    "sourceFile": "ex2/L3Switch.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 36,
            "patches": [
                {
                    "date": 1651651762506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1651651785832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,10 +21,11 @@\n from ryu.lib.packet import packet\n from ryu.lib.packet import ethernet\n from ryu.lib.packet import ether_types\n from ryu.lib.packet import ipv4\n+from ryu.lib.packet import in_proto\n+from ryu.lib.packet import icmp\n \n-\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n     def __init__(self, *args, **kwargs):\n"
                },
                {
                    "date": 1651651828966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,12 +109,13 @@\n             if eth.ethertype == ether_types.ETH_TYPE_IP:\n                 ip = pkt.get_protocol(ipv4.ipv4)\n                 srcip = ip.src\n                 dstip = ip.dst\n-                match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP,\n-                                        ipv4_src=srcip,\n-                                        ipv4_dst=dstip\n-                                        )\n+                protocol = ip.proto\n+                \n+                if protocol == in_proto.IPPROTO_ICMP:\n+                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip, ip_proto=protocol)\n+                \n                 # verify if we have a valid buffer_id, if yes avoid to send both\n                 # flow_mod & packet_out\n                 if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                     self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n"
                },
                {
                    "date": 1651651966420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,15 +57,14 @@\n         inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                              actions)]\n         if buffer_id:\n             mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n-                                    priority=priority, match=match,\n+                                    idle_timeout=10, hard_timeout=30, priority=priority, match=match,\n                                     instructions=inst)\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n-                                    match=match, instructions=inst)\n+                                    idle_timeout=10, hard_timeout=30, match=match, instructions=inst)\n         datapath.send_msg(mod)\n-\n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n"
                },
                {
                    "date": 1651652252969,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,8 +24,11 @@\n from ryu.lib.packet import ipv4\n from ryu.lib.packet import in_proto\n from ryu.lib.packet import icmp\n \n+FILTER_TABLE = 5\n+FORWARD_TABLE = 10\n+\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n     def __init__(self, *args, **kwargs):\n@@ -63,8 +66,36 @@\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                     idle_timeout=10, hard_timeout=30, match=match, instructions=inst)\n         datapath.send_msg(mod)\n+        \n+    \n+    def add_default_table(self, datapath):\n+        ofproto = datapath.ofproto\n+        parser = datapath.ofproto_parser\n+        inst = [parser.OFPInstructionGotoTable(FILTER_TABLE)]\n+        mod = parser.OFPFlowMod(datapath=datapath, table_id=0, instructions=inst)\n+        datapath.send_msg(mod)\n+\n+    def add_filter_table(self, datapath):\n+        ofproto = datapath.ofproto\n+        parser = datapath.ofproto_parser\n+        inst = [parser.OFPInstructionGotoTable(FORWARD_TABLE)]\n+        mod = parser.OFPFlowMod(datapath=datapath, table_id=FILTER_TABLE, \n+                                priority=1, instructions=inst)\n+        datapath.send_msg(mod)\n+\n+    def apply_filter_table_rules(self, datapath):\n+        ofproto = datapath.ofproto\n+        parser = datapath.ofproto_parser\n+        match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ip_proto=in_proto.IPPROTO_ICMP)\n+        mod = parser.OFPFlowMod(datapath=datapath, table_id=FILTER_TABLE,\n+                                priority=10000, match=match)\n+        datapath.send_msg(mod)\n+\n+    \n+    \n+    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n"
                },
                {
                    "date": 1651652581836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,11 +24,8 @@\n from ryu.lib.packet import ipv4\n from ryu.lib.packet import in_proto\n from ryu.lib.packet import icmp\n \n-FILTER_TABLE = 5\n-FORWARD_TABLE = 10\n-\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n     def __init__(self, *args, **kwargs):\n@@ -67,35 +64,11 @@\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                     idle_timeout=10, hard_timeout=30, match=match, instructions=inst)\n         datapath.send_msg(mod)\n         \n-    \n-    def add_default_table(self, datapath):\n-        ofproto = datapath.ofproto\n-        parser = datapath.ofproto_parser\n-        inst = [parser.OFPInstructionGotoTable(FILTER_TABLE)]\n-        mod = parser.OFPFlowMod(datapath=datapath, table_id=0, instructions=inst)\n-        datapath.send_msg(mod)\n \n-    def add_filter_table(self, datapath):\n-        ofproto = datapath.ofproto\n-        parser = datapath.ofproto_parser\n-        inst = [parser.OFPInstructionGotoTable(FORWARD_TABLE)]\n-        mod = parser.OFPFlowMod(datapath=datapath, table_id=FILTER_TABLE, \n-                                priority=1, instructions=inst)\n-        datapath.send_msg(mod)\n-\n-    def apply_filter_table_rules(self, datapath):\n-        ofproto = datapath.ofproto\n-        parser = datapath.ofproto_parser\n-        match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ip_proto=in_proto.IPPROTO_ICMP)\n-        mod = parser.OFPFlowMod(datapath=datapath, table_id=FILTER_TABLE,\n-                                priority=10000, match=match)\n-        datapath.send_msg(mod)\n-\n     \n     \n-    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n"
                },
                {
                    "date": 1651652755705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,8 +55,12 @@\n         parser = datapath.ofproto_parser\n \n         inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                              actions)]\n+        \n+        if parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IPV6):\n+            mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n+        \n         if buffer_id:\n             mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n                                     idle_timeout=10, hard_timeout=30, priority=priority, match=match,\n                                     instructions=inst)\n"
                },
                {
                    "date": 1651652850206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,8 @@\n from ryu.lib.packet import ethernet\n from ryu.lib.packet import ether_types\n from ryu.lib.packet import ipv4\n from ryu.lib.packet import in_proto\n-from ryu.lib.packet import icmp\n \n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n"
                },
                {
                    "date": 1651652865822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,12 @@\n from ryu.lib.packet import ethernet\n from ryu.lib.packet import ether_types\n from ryu.lib.packet import ipv4\n from ryu.lib.packet import in_proto\n+from ryu.lib.packet import icmp\n+from ryu.lib.packet import arp\n \n+\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n     def __init__(self, *args, **kwargs):\n"
                },
                {
                    "date": 1651652932841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,32 @@\n         datapath.send_msg(mod)\n         \n \n     \n+    def arp_process(self, datapath, eth, a, in_port):\n+        r = arp_table.get(a.dst_ip)\n+        if r:\n+            self.logger.info(\"Matched MAC %s \", r)\n+            arp_resp = packet.Packet()\n+            arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n+                                    dst=eth.src, src=r))\n+            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n+                                    src_mac=r, src_ip=a.dst_ip,\n+                                    dst_mac=a.src_mac,\n+                                    dst_ip=a.src_ip))\n+\n+            arp_resp.serialize()\n+            actions = []\n+            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n+            parser = datapath.ofproto_parser  \n+            ofproto = datapath.ofproto\n+            out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n+                                    in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n+            datapath.send_msg(out)\n+            self.logger.info(\"Proxied ARP Response packet\")\n+\n     \n+    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n@@ -137,4 +160,5 @@\n \n         out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,\n                                   in_port=in_port, actions=actions, data=data)\n         datapath.send_msg(out)\n+\n"
                },
                {
                    "date": 1651653001850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,16 +145,17 @@\n                 protocol = ip.proto\n                 \n                 if protocol == in_proto.IPPROTO_ICMP:\n                     match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip, ip_proto=protocol)\n-                \n                 # verify if we have a valid buffer_id, if yes avoid to send both\n                 # flow_mod & packet_out\n                 if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                     self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                     return\n                 else:\n                     self.add_flow(datapath, 1, match, actions)\n+            elif eth.ethertype == ether_types.ETH_TYPE_ARP:\n+                self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n         data = None\n         if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n             data = msg.data\n \n"
                },
                {
                    "date": 1651653018567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,8 +154,11 @@\n                 else:\n                     self.add_flow(datapath, 1, match, actions)\n             elif eth.ethertype == ether_types.ETH_TYPE_ARP:\n                 self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n+                arp = pkt.get_protocol(arp.arp)\n+                self.arp_process(datapath, eth, arp, in_port)\n+                return\n         data = None\n         if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n             data = msg.data\n \n"
                },
                {
                    "date": 1651654078318,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,19 +1,4 @@\n-# Copyright (C) 2011 Nippon Telegraph and Telephone Corporation.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-#\n-#    http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-# implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n from ryu.base import app_manager\n from ryu.controller import ofp_event\n from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\n from ryu.controller.handler import set_ev_cls\n"
                },
                {
                    "date": 1651654107001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,9 @@\n \n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n+    arp_table = {}\n     def __init__(self, *args, **kwargs):\n         super(SimpleSwitch13, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n \n"
                },
                {
                    "date": 1651654366915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,12 +11,22 @@\n from ryu.lib.packet import icmp\n from ryu.lib.packet import arp\n \n \n+arp_table = {\"10.0.1.1\": \"00:00:00:00:00:01\",\n+            \"10.0.1.2\": \"00:00:00:00:00:02\",\n+            \"10.0.1.3\": \"00:00:00:00:00:03\",\n+            \"10.0.2.1\": \"00:00:00:00:00:04\",\n+            \"10.0.2.2\": \"00:00:00:00:00:05\",\n+            \"10.0.2.3\": \"00:00:00:00:00:06\",\n+            \"10.0.3.1\": \"00:00:00:00:00:07\",\n+            \"10.0.3.2\": \"00:00:00:00:00:08\",\n+            \"10.0.3.3\": \"00:00:00:00:00:09\",\n+}\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n-    arp_table = {}\n+\n     def __init__(self, *args, **kwargs):\n         super(SimpleSwitch13, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n \n"
                },
                {
                    "date": 1651654815190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,8 +121,15 @@\n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n         self.mac_to_port[dpid][src] = in_port\n+        \n+        #check if arp packet is received\n+        if eth.ethertype == ether_types.ETH_TYPE_ARP:\n+            self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n+            arp = pkt.get_protocol(arp.arp)\n+            self.arp_process(datapath, eth, arp, in_port)\n+            return\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n         else:\n@@ -148,13 +155,8 @@\n                     self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                     return\n                 else:\n                     self.add_flow(datapath, 1, match, actions)\n-            elif eth.ethertype == ether_types.ETH_TYPE_ARP:\n-                self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n-                arp = pkt.get_protocol(arp.arp)\n-                self.arp_process(datapath, eth, arp, in_port)\n-                return\n         data = None\n         if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n             data = msg.data\n \n"
                },
                {
                    "date": 1651654952325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,9 +125,9 @@\n         \n         #check if arp packet is received\n         if eth.ethertype == ether_types.ETH_TYPE_ARP:\n             self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n-            arp = pkt.get_protocol(arp.arp)\n+            a = pkt.get_protocol(arp.arp)\n             self.arp_process(datapath, eth, arp, in_port)\n             return\n \n         if dst in self.mac_to_port[dpid]:\n"
                },
                {
                    "date": 1651654962673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,9 +126,9 @@\n         #check if arp packet is received\n         if eth.ethertype == ether_types.ETH_TYPE_ARP:\n             self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n             a = pkt.get_protocol(arp.arp)\n-            self.arp_process(datapath, eth, arp, in_port)\n+            self.arp_process(datapath, eth, a, in_port)\n             return\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n"
                },
                {
                    "date": 1651655268575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,13 +59,13 @@\n             mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n         \n         if buffer_id:\n             mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n-                                    idle_timeout=10, hard_timeout=30, priority=priority, match=match,\n+                                    idle_timeout=200, hard_timeout=200, priority=priority, match=match,\n                                     instructions=inst)\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n-                                    idle_timeout=10, hard_timeout=30, match=match, instructions=inst)\n+                                    idle_timeout=200, hard_timeout=200, match=match, instructions=inst)\n         datapath.send_msg(mod)\n         \n \n     \n"
                },
                {
                    "date": 1651655556266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,13 +59,13 @@\n             mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n         \n         if buffer_id:\n             mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n-                                    idle_timeout=200, hard_timeout=200, priority=priority, match=match,\n+                                    idle_timeout=200, hard_timeout=500, priority=priority, match=match,\n                                     instructions=inst)\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n-                                    idle_timeout=200, hard_timeout=200, match=match, instructions=inst)\n+                                    idle_timeout=200, hard_timeout=500, match=match, instructions=inst)\n         datapath.send_msg(mod)\n         \n \n     \n"
                },
                {
                    "date": 1651655761128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,13 +59,13 @@\n             mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n         \n         if buffer_id:\n             mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n-                                    idle_timeout=200, hard_timeout=500, priority=priority, match=match,\n+                                    idle_timeout=500, hard_timeout=500, priority=priority, match=match,\n                                     instructions=inst)\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n-                                    idle_timeout=200, hard_timeout=500, match=match, instructions=inst)\n+                                    idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n         datapath.send_msg(mod)\n         \n \n     \n"
                },
                {
                    "date": 1651656528610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,11 @@\n             out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n             self.logger.info(\"Proxied ARP Response packet\")\n-\n+        else: \n+            print(r)\n+            print(\"there was some problem\")\n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n"
                },
                {
                    "date": 1651657254302,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,17 +11,17 @@\n from ryu.lib.packet import icmp\n from ryu.lib.packet import arp\n \n \n-arp_table = {\"10.0.1.1\": \"00:00:00:00:00:01\",\n-            \"10.0.1.2\": \"00:00:00:00:00:02\",\n-            \"10.0.1.3\": \"00:00:00:00:00:03\",\n-            \"10.0.2.1\": \"00:00:00:00:00:04\",\n-            \"10.0.2.2\": \"00:00:00:00:00:05\",\n-            \"10.0.2.3\": \"00:00:00:00:00:06\",\n-            \"10.0.3.1\": \"00:00:00:00:00:07\",\n-            \"10.0.3.2\": \"00:00:00:00:00:08\",\n-            \"10.0.3.3\": \"00:00:00:00:00:09\",\n+arp_table = {\"10.0.0.249\": \"00:00:00:00:00:01\",\n+            \"10.0.0.250\": \"00:00:00:00:00:02\",\n+            \"10.0.0.251\": \"00:00:00:00:00:03\",\n+            \"10.1.0.249\": \"00:00:00:00:00:04\",\n+            \"10.1.0.250\": \"00:00:00:00:00:05\",\n+            \"10.1.0.251\": \"00:00:00:00:00:06\",\n+            \"10.2.0.1\": \"00:00:00:00:00:07\",\n+            \"10.2.0.2\": \"00:00:00:00:00:08\",\n+            \"10.2.0.3\": \"00:00:00:00:00:09\",\n }\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n"
                },
                {
                    "date": 1651657263470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,11 +17,11 @@\n             \"10.0.0.251\": \"00:00:00:00:00:03\",\n             \"10.1.0.249\": \"00:00:00:00:00:04\",\n             \"10.1.0.250\": \"00:00:00:00:00:05\",\n             \"10.1.0.251\": \"00:00:00:00:00:06\",\n-            \"10.2.0.1\": \"00:00:00:00:00:07\",\n-            \"10.2.0.2\": \"00:00:00:00:00:08\",\n-            \"10.2.0.3\": \"00:00:00:00:00:09\",\n+            \"10.2.0.249\": \"00:00:00:00:00:07\",\n+            \"10.2.0.250\": \"00:00:00:00:00:08\",\n+            \"10.2.0.251\": \"00:00:00:00:00:09\",\n }\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n"
                },
                {
                    "date": 1651657463452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,17 +11,17 @@\n from ryu.lib.packet import icmp\n from ryu.lib.packet import arp\n \n \n-arp_table = {\"10.0.0.249\": \"00:00:00:00:00:01\",\n-            \"10.0.0.250\": \"00:00:00:00:00:02\",\n-            \"10.0.0.251\": \"00:00:00:00:00:03\",\n-            \"10.1.0.249\": \"00:00:00:00:00:04\",\n-            \"10.1.0.250\": \"00:00:00:00:00:05\",\n-            \"10.1.0.251\": \"00:00:00:00:00:06\",\n-            \"10.2.0.249\": \"00:00:00:00:00:07\",\n-            \"10.2.0.250\": \"00:00:00:00:00:08\",\n-            \"10.2.0.251\": \"00:00:00:00:00:09\",\n+arp_table = {\"10.0.0.1\": \"00:00:00:00:00:01\",\n+            \"10.0.1.2\": \"00:00:00:00:00:02\",\n+            \"10.0.1.3\": \"00:00:00:00:00:03\",\n+            \"10.0.2.1\": \"00:00:00:00:00:04\",\n+            \"10.0.2.2\": \"00:00:00:00:00:05\",\n+            \"10.0.2.3\": \"00:00:00:00:00:06\",\n+            \"10.0.3.1\": \"00:00:00:00:00:07\",\n+            \"10.0.3.2\": \"00:00:00:00:00:08\",\n+            \"10.0.3.3\": \"00:00:00:00:00:09\",\n }\n class SimpleSwitch13(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n"
                },
                {
                    "date": 1651657799433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n from ryu.lib.packet import icmp\n from ryu.lib.packet import arp\n \n \n-arp_table = {\"10.0.0.1\": \"00:00:00:00:00:01\",\n+arp_table = {\"10.0.1.1\": \"00:00:00:00:00:01\",\n             \"10.0.1.2\": \"00:00:00:00:00:02\",\n             \"10.0.1.3\": \"00:00:00:00:00:03\",\n             \"10.0.2.1\": \"00:00:00:00:00:04\",\n             \"10.0.2.2\": \"00:00:00:00:00:05\",\n"
                },
                {
                    "date": 1651690468271,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n             \"10.0.3.1\": \"00:00:00:00:00:07\",\n             \"10.0.3.2\": \"00:00:00:00:00:08\",\n             \"10.0.3.3\": \"00:00:00:00:00:09\",\n }\n-class SimpleSwitch13(app_manager.RyuApp):\n+class L3Switch(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n \n     def __init__(self, *args, **kwargs):\n"
                },
                {
                    "date": 1651690485482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n \n     def __init__(self, *args, **kwargs):\n-        super(SimpleSwitch13, self).__init__(*args, **kwargs)\n+        super(L3Switch, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n"
                },
                {
                    "date": 1651690525173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,9 @@\n         \n \n     \n     def arp_process(self, datapath, eth, a, in_port):\n-        r = arp_table.get(a.dst_ip)\n+        r = self.arp_table.get(a.dst_ip)\n         if r:\n             self.logger.info(\"Matched MAC %s \", r)\n             arp_resp = packet.Packet()\n             arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n"
                },
                {
                    "date": 1651690546353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,17 @@\n from ryu.lib.packet import icmp\n from ryu.lib.packet import arp\n \n \n-arp_table = {\"10.0.1.1\": \"00:00:00:00:00:01\",\n+\n+class L3Switch(app_manager.RyuApp):\n+    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n+\n+\n+    def __init__(self, *args, **kwargs):\n+        super(L3Switch, self).__init__(*args, **kwargs)\n+        self.mac_to_port = {}\n+        self.arp_table = {\"10.0.1.1\": \"00:00:00:00:00:01\",\n             \"10.0.1.2\": \"00:00:00:00:00:02\",\n             \"10.0.1.3\": \"00:00:00:00:00:03\",\n             \"10.0.2.1\": \"00:00:00:00:00:04\",\n             \"10.0.2.2\": \"00:00:00:00:00:05\",\n@@ -21,16 +29,9 @@\n             \"10.0.3.1\": \"00:00:00:00:00:07\",\n             \"10.0.3.2\": \"00:00:00:00:00:08\",\n             \"10.0.3.3\": \"00:00:00:00:00:09\",\n }\n-class L3Switch(app_manager.RyuApp):\n-    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n-\n-    def __init__(self, *args, **kwargs):\n-        super(L3Switch, self).__init__(*args, **kwargs)\n-        self.mac_to_port = {}\n-\n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n         ofproto = datapath.ofproto\n"
                },
                {
                    "date": 1651690654346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,15 +36,8 @@\n         datapath = ev.msg.datapath\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n \n-        # install table-miss flow entry\n-        #\n-        # We specify NO BUFFER to max_len of the output action due to\n-        # OVS bug. At this moment, if we specify a lesser number, e.g.,\n-        # 128, OVS will send Packet-In with invalid buffer_id and\n-        # truncated packet data. In that case, we cannot output packets\n-        # correctly.  The bug has been fixed in OVS v2.1.0.\n         match = parser.OFPMatch()\n         actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                           ofproto.OFPCML_NO_BUFFER)]\n         self.add_flow(datapath, 0, match, actions)\n"
                },
                {
                    "date": 1651691324371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,11 +83,8 @@\n             out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n             self.logger.info(\"Proxied ARP Response packet\")\n-        else: \n-            print(r)\n-            print(\"there was some problem\")\n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n"
                },
                {
                    "date": 1651691342825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,8 +83,10 @@\n             out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n             self.logger.info(\"Proxied ARP Response packet\")\n+        else: \n+            print(\"No arp detected\")\n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n"
                },
                {
                    "date": 1651691348352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n             self.logger.info(\"Proxied ARP Response packet\")\n         else: \n-            print(\"No arp detected\")\n+            print(\"Arp não detectado\")\n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n"
                },
                {
                    "date": 1651691361583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n             ofproto = datapath.ofproto\n             out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n-            self.logger.info(\"Proxied ARP Response packet\")\n+            self.logger.info(\"Enviado ARP Response packet\")\n         else: \n             print(\"Arp não detectado\")\n     \n     \n"
                },
                {
                    "date": 1651693211398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,19 +134,16 @@\n \n         # install a flow to avoid packet_in next time\n         if out_port != ofproto.OFPP_FLOOD:\n \n-            # check IP Protocol and create a match for IP\n             if eth.ethertype == ether_types.ETH_TYPE_IP:\n                 ip = pkt.get_protocol(ipv4.ipv4)\n                 srcip = ip.src\n                 dstip = ip.dst\n                 protocol = ip.proto\n                 \n                 if protocol == in_proto.IPPROTO_ICMP:\n                     match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip, ip_proto=protocol)\n-                # verify if we have a valid buffer_id, if yes avoid to send both\n-                # flow_mod & packet_out\n                 if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                     self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                     return\n                 else:\n"
                },
                {
                    "date": 1651693281810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,9 +141,9 @@\n                 dstip = ip.dst\n                 protocol = ip.proto\n                 \n                 if protocol == in_proto.IPPROTO_ICMP:\n-                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip, ip_proto=protocol)\n+                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip)\n                 if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                     self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                     return\n                 else:\n"
                }
            ],
            "date": 1651651762506,
            "name": "Commit-0",
            "content": "# Copyright (C) 2011 Nippon Telegraph and Telephone Corporation.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ryu.base import app_manager\nfrom ryu.controller import ofp_event\nfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\nfrom ryu.controller.handler import set_ev_cls\nfrom ryu.ofproto import ofproto_v1_3\nfrom ryu.lib.packet import packet\nfrom ryu.lib.packet import ethernet\nfrom ryu.lib.packet import ether_types\nfrom ryu.lib.packet import ipv4\n\n\nclass SimpleSwitch13(app_manager.RyuApp):\n    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n\n    def __init__(self, *args, **kwargs):\n        super(SimpleSwitch13, self).__init__(*args, **kwargs)\n        self.mac_to_port = {}\n\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n    def switch_features_handler(self, ev):\n        datapath = ev.msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        # install table-miss flow entry\n        #\n        # We specify NO BUFFER to max_len of the output action due to\n        # OVS bug. At this moment, if we specify a lesser number, e.g.,\n        # 128, OVS will send Packet-In with invalid buffer_id and\n        # truncated packet data. In that case, we cannot output packets\n        # correctly.  The bug has been fixed in OVS v2.1.0.\n        match = parser.OFPMatch()\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                          ofproto.OFPCML_NO_BUFFER)]\n        self.add_flow(datapath, 0, match, actions)\n\n    def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                             actions)]\n        if buffer_id:\n            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n                                    priority=priority, match=match,\n                                    instructions=inst)\n        else:\n            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                    match=match, instructions=inst)\n        datapath.send_msg(mod)\n\n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n    def _packet_in_handler(self, ev):\n        # If you hit this you might want to increase\n        # the \"miss_send_length\" of your switch\n        if ev.msg.msg_len < ev.msg.total_len:\n            self.logger.debug(\"packet truncated: only %s of %s bytes\",\n                              ev.msg.msg_len, ev.msg.total_len)\n        msg = ev.msg\n        datapath = msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n        in_port = msg.match['in_port']\n\n        pkt = packet.Packet(msg.data)\n        eth = pkt.get_protocols(ethernet.ethernet)[0]\n\n        if eth.ethertype == ether_types.ETH_TYPE_LLDP:\n            # ignore lldp packet\n            return\n        dst = eth.dst\n        src = eth.src\n\n        dpid = datapath.id\n        self.mac_to_port.setdefault(dpid, {})\n\n        self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n\n        # learn a mac address to avoid FLOOD next time.\n        self.mac_to_port[dpid][src] = in_port\n\n        if dst in self.mac_to_port[dpid]:\n            out_port = self.mac_to_port[dpid][dst]\n        else:\n            out_port = ofproto.OFPP_FLOOD\n\n        actions = [parser.OFPActionOutput(out_port)]\n\n        # install a flow to avoid packet_in next time\n        if out_port != ofproto.OFPP_FLOOD:\n\n            # check IP Protocol and create a match for IP\n            if eth.ethertype == ether_types.ETH_TYPE_IP:\n                ip = pkt.get_protocol(ipv4.ipv4)\n                srcip = ip.src\n                dstip = ip.dst\n                match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP,\n                                        ipv4_src=srcip,\n                                        ipv4_dst=dstip\n                                        )\n                # verify if we have a valid buffer_id, if yes avoid to send both\n                # flow_mod & packet_out\n                if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                    self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                    return\n                else:\n                    self.add_flow(datapath, 1, match, actions)\n        data = None\n        if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n            data = msg.data\n\n        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,\n                                  in_port=in_port, actions=actions, data=data)\n        datapath.send_msg(out)\n"
        }
    ]
}
{
    "sourceFile": "TP1/ex2/L3Switch.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1652202017029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1652205105876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,18 +19,8 @@\n \n     def __init__(self, *args, **kwargs):\n         super(L3Switch, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n-        self.arp_table = {\"10.0.1.254\": \"00:00:00:00:00:01\",\n-            \"10.0.1.2\": \"00:00:00:00:00:02\",\n-            \"10.0.1.3\": \"00:00:00:00:00:03\",\n-            \"10.0.2.254\": \"00:00:00:00:00:04\",\n-            \"10.0.2.2\": \"00:00:00:00:00:05\",\n-            \"10.0.2.3\": \"00:00:00:00:00:06\",\n-            \"10.0.3.1\": \"00:00:00:00:00:07\",\n-            \"10.0.3.2\": \"00:00:00:00:00:08\",\n-            \"10.0.3.3\": \"00:00:00:00:00:09\",\n-}\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n"
                },
                {
                    "date": 1652290807147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,146 +3,296 @@\n from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\n from ryu.controller.handler import set_ev_cls\n from ryu.ofproto import ofproto_v1_3\n from ryu.lib.packet import packet\n+from ryu.lib.packet import ether_types\n+from ryu.lib.packet import packet_base\n from ryu.lib.packet import ethernet\n-from ryu.lib.packet import ether_types\n+from ryu.lib.packet import arp\n+from ryu.lib.packet import ethernet\n+from ryu.lib.packet import icmp\n from ryu.lib.packet import ipv4\n-from ryu.lib.packet import in_proto\n-from ryu.lib.packet import icmp\n-from ryu.lib.packet import arp\n+from ryu.lib.packet import packet\n+from ryu.lib.packet import packet_base\n+from ryu.lib.packet import tcp\n+from ryu.lib.packet import udp\n+from ryu.ofproto import ether\n \n+ETHERNET = ethernet.ethernet.__name__\n+IPV4 = ipv4.ipv4.__name__\n+ARP = arp.arp.__name__\n+ICMP = icmp.icmp.__name__\n+TCP = tcp.tcp.__name__\n+UDP = udp.udp.__name__\n \n \n-class L3Switch(app_manager.RyuApp):\n+\n+\n+class SwitchL3(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n+    \"\"\"Contrutor para a classe com as seguintes tabelas:\n+        - ip_to_mac: dicionario de ip para mac\n+        - ip_to_port: dicionario de ip para porta (L3)\n+        - router_ports: dicionario de porta para ip \n+        - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\n+        - packet_queue: dicionario fila de pacotes arp\n+    \"\"\"\n \n     def __init__(self, *args, **kwargs):\n-        super(L3Switch, self).__init__(*args, **kwargs)\n-        self.mac_to_port = {}\n+        super(SwitchL3, self).__init__(*args, **kwargs)\n+        self.ip_to_mac = {}\n+        self.ip_to_port = {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1,\n+                           '10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2,\n+                           '10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3,}\n+        self.router_ports = {}\n+        self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\n+        \n+        self.packet_queue = {}\n \n+\n+    \"\"\"\n+    Função responsável pelo evento correspondente ao ennvio das funcionaliades presentes no switch para o controlado\n+    \"\"\"\n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n \n         match = parser.OFPMatch()\n-        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n-                                          ofproto.OFPCML_NO_BUFFER)]\n+        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]\n+\n         self.add_flow(datapath, 0, match, actions)\n \n+        match = parser.OFPMatch(eth_type = ether_types.ETH_TYPE_IPV6)\n+        actions = []\n+\n+        self.add_flow(datapath, 1, match, actions)\n+        self.port_desc(datapath)\n+\n+    #Utility Function\n+    def port_desc(self, datapath):\n+        ofparser = datapath.ofproto_parser\n+\n+        req = ofparser.OFPPortDescStatsRequest(datapath,0)\n+        datapath.send_msg(req)\n+\n+    #Utility Function\n+    @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\n+    def port_desc_stats_reply_handle(self,ev):\n+\n+        dpid = ev.msg.datapath.id\n+        self.router_ports.setdefault(dpid, {})\n+        for p in ev.msg.body:\n+            self.router_ports[dpid].update({ p.port_no: p.hw_addr})\n+        \n+        print(\"Router \",dpid)\n+        for p in self.router_ports[dpid].keys():\n+            print(f\"Port {p} has MAC {self.router_ports[dpid][p]}\")\n+\n+        print(\"\\n\")\n+\n+    #Adcionar flows\n     def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n \n         inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                              actions)]\n-        \n-        if parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IPV6):\n-            mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n-        \n         if buffer_id:\n             mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n-                                    idle_timeout=500, hard_timeout=500, priority=priority, match=match,\n+                                    priority=priority, match=match,\n                                     instructions=inst)\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n-                                    idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n+                                    match=match, instructions=inst)\n         datapath.send_msg(mod)\n-        \n+ \n \n-    \n-    def arp_process(self, datapath, eth, a, in_port):\n-        r = self.arp_table.get(a.dst_ip)\n-        if r:\n-            self.logger.info(\"Matched MAC %s \", r)\n-            arp_resp = packet.Packet()\n-            arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n-                                    dst=eth.src, src=r))\n-            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n-                                    src_mac=r, src_ip=a.dst_ip,\n-                                    dst_mac=a.src_mac,\n-                                    dst_ip=a.src_ip))\n-\n-            arp_resp.serialize()\n-            actions = []\n-            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n-            parser = datapath.ofproto_parser  \n-            ofproto = datapath.ofproto\n-            out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n-                                    in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n-            datapath.send_msg(out)\n-            self.logger.info(\"Enviado ARP Response packet para %s\", r)\n-        else: \n-            print(\"Endereço não encontrado\")\n-    \n-    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n-    def _packet_in_handler(self, ev):\n-        # If you hit this you might want to increase\n-        # the \"miss_send_length\" of your switch\n-        if ev.msg.msg_len < ev.msg.total_len:\n-            self.logger.debug(\"packet truncated: only %s of %s bytes\",\n-                              ev.msg.msg_len, ev.msg.total_len)\n+    def packet_in_handler(self, ev):\n         msg = ev.msg\n-        datapath = msg.datapath\n+        dpid = msg.datapath.id        \n+        port = msg.match['in_port']\n+        pkt = packet.Packet(msg.data)\n+\n+        #self.logger.info(\"\\npacket-in %s\" % (pkt,))\n+\n+        pkt_ethernet = pkt.get_protocol(ethernet.ethernet)\n+        if not pkt_ethernet:\n+            return\n+        pkt_arp = pkt.get_protocol(arp.arp)\n+        if pkt_arp:\n+            #ARP handling\n+            self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n+            return\n+        pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n+        if pkt_ipv4:\n+            if pkt_ipv4.dst in self.router_ports_to_ip.values():\n+                pkt_icmp = pkt.get_protocol(icmp.icmp)\n+                if pkt_icmp:\n+                    self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n+                    return\n+            else:\n+                #Static routing handling\n+                if pkt_ipv4.dst in self.ip_to_port.keys():\n+                    self.logger.info(\"\\nPacket received by router %s from %s to %s \", dpid, pkt_ipv4.src, pkt_ipv4.dst)\n+                    self.ip_to_mac.setdefault(dpid, {})\n+                    if pkt_ipv4.dst in self.ip_to_mac[dpid].keys():\n+                        out_port = self.ip_to_port[pkt_ipv4.dst]\n+                        pkt_ethernet.src = self.router_ports[dpid][out_port]\n+                        pkt_ethernet.dst = self.ip_to_mac[dpid][pkt_ipv4.dst]\n+                        self.send_packet(msg.datapath,out_port,pkt)\n+                        return\n+\n+                    else:\n+                        #Send ARP Request\n+                        self.packet_queue.setdefault(pkt_ipv4.dst,[])\n+                        self.packet_queue[pkt_ipv4.dst].append(msg)\n+                        self.logger.info(\"\\nRouter %s doesn't know MAC of %s adding packet to queue\", dpid, pkt_ipv4.dst)\n+                        self.send_arp_request(msg, pkt_ipv4)\n+                        return\n+\n+                else:\n+                    self.logger.info(\"\\nPacket received by router %s from %s to %s (unknown destination)\", dpid, pkt_ipv4.src, pkt_ipv4.dst)\n+                    self.send_icmp_unreachable(msg, port, pkt_ethernet, pkt_ipv4)\n+                    #Send ICMP network unreachable\n+                   \n+\n+\n+    def send_arp_request(self, msg, pkt_ipv4):\n+        out_port = self.ip_to_port[pkt_ipv4.dst]\n+        src_mac = self.router_ports[msg.datapath.id][out_port]\n+        src_ip = self.router_ports_to_ip[out_port]\n+\n+\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\n+                                           dst='ff:ff:ff:ff:ff:ff',\n+                                           src=src_mac))\n+        pkt.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\n+                                 src_mac=src_mac,\n+                                 src_ip=src_ip,\n+                                 dst_mac='ff:ff:ff:ff:ff:ff',\n+                                 dst_ip=pkt_ipv4.dst))\n+\n+        self.send_packet(msg.datapath,out_port,pkt)\n+\n+        self.logger.info(\"\\nRouter %s sending ARP Request from port %s to learn MAC of %s\", msg.datapath.id, out_port, pkt_ipv4.dst)\n+\n+\n+    def send_packet(self, datapath, port, pkt):\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n-        in_port = msg.match['in_port']\n+        pkt.serialize()\n+        data = pkt.data\n+        actions = [parser.OFPActionOutput(port=port)]\n+        out = parser.OFPPacketOut(datapath=datapath,\n+                                  buffer_id=ofproto.OFP_NO_BUFFER,\n+                                  in_port=ofproto.OFPP_CONTROLLER,\n+                                  actions=actions,\n+                                  data=data)\n+        datapath.send_msg(out)\n \n-        pkt = packet.Packet(msg.data)\n-        eth = pkt.get_protocols(ethernet.ethernet)[0]\n \n-        if eth.ethertype == ether_types.ETH_TYPE_LLDP:\n-            # ignore lldp packet\n-            return\n-        dst = eth.dst\n-        src = eth.src\n+    def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\n+        #ARP packet handling.\n+        dpid = msg.datapath.id\n \n-        dpid = datapath.id\n-        self.mac_to_port.setdefault(dpid, {})\n+        if pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REQUEST:\n \n-        self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n+            self.logger.info(\"\\nARP Request received by router %s from %s in port %s \", dpid, pkt_arp.src_ip, port)\n \n-        # learn a mac address to avoid FLOOD next time.\n-        self.mac_to_port[dpid][src] = in_port\n-        \n-        #check if arp packet is received\n-        if eth.ethertype == ether_types.ETH_TYPE_ARP:\n-            self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n-            a = pkt.get_protocol(arp.arp)\n-            self.arp_process(datapath, eth, a, in_port)\n+            port_mac = self.router_ports[dpid][port]\n+\n+            pkt = packet.Packet()\n+            pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\n+                                           dst=pkt_ethernet.src,\n+                                           src=port_mac))\n+            pkt.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n+                                 src_mac=port_mac,\n+                                 src_ip=pkt_arp.dst_ip,\n+                                 dst_mac=pkt_arp.src_mac,\n+                                 dst_ip=pkt_arp.src_ip))\n+            self.send_packet(msg.datapath, port, pkt)\n+\n+            self.logger.info(\"ARP Reply sent by router %s from port %s with MAC %s to %s\", dpid, port, port_mac, pkt_arp.src_ip)\n+\n             return\n+        elif pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REPLY:\n+            self.logger.info(\"\\nARP Reply received by router %s from %s with MAC %s\", dpid, pkt_arp.src_ip, pkt_arp.src_mac)\n+            self.ip_to_mac.setdefault(dpid, {})\n+            self.ip_to_mac[dpid][pkt_arp.src_ip] = pkt_arp.src_mac\n \n-        if dst in self.mac_to_port[dpid]:\n-            out_port = self.mac_to_port[dpid][dst]\n+            for m in self.packet_queue[pkt_arp.src_ip]:\n+                dpid = m.datapath.id        \n+                pkt = packet.Packet(m.data)\n+                pkt_eth = pkt.get_protocol(ethernet.ethernet)\n+                pkt_v4 = pkt.get_protocol(ipv4.ipv4)\n+                out_port = self.ip_to_port[pkt_arp.src_ip]\n+                pkt_eth.src = self.router_ports[dpid][out_port]\n+                pkt_eth.dst = self.ip_to_mac[dpid][pkt_arp.src_ip]\n+                self.send_packet(msg.datapath,out_port,pkt)\n+                self.logger.info(\"Router %s sent queued packet from %s to %s\", dpid, pkt_v4.src, pkt_v4.dst)\n+\n+  \n+            #cycle through all packets to this ip and forward them\n+            return\n         else:\n-            out_port = ofproto.OFPP_FLOOD\n+            self.logger.info(\"\\nARP Packet dropped router %s, %s not an interface ip\", dpid, pkt_arp.dst_ip)\n+            \n+            #Any other case pass\n+            return\n \n-        actions = [parser.OFPActionOutput(out_port)]\n \n-        # install a flow to avoid packet_in next time\n-        if out_port != ofproto.OFPP_FLOOD:\n+    def handle_icmp(self, msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp):\n+        # Send ICMP echo reply.\n \n-            if eth.ethertype == ether_types.ETH_TYPE_IP:\n-                ip = pkt.get_protocol(ipv4.ipv4)\n-                srcip = ip.src\n-                dstip = ip.dst\n-                protocol = ip.proto\n-                \n-                if protocol == in_proto.IPPROTO_ICMP:\n-                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip)\n-                if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n-                    self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n-                    return\n-                else:\n-                    self.add_flow(datapath, 1, match, actions)\n-        data = None\n-        if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n-            data = msg.data\n+        dpid = msg.datapath.id\n+        src_ip = pkt_ipv4.src\n+        self.logger.info('\\nICMP echo request received by router %s port %s from %s to %s.', dpid, port, src_ip, pkt_ipv4.dst)\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\n+                                           dst=pkt_ethernet.src,\n+                                           src=self.router_ports[dpid][port]))\n+        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\n+                                   src=self.router_ports_to_ip[port],\n+                                   proto=pkt_ipv4.proto))\n+        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\n+                                   code=icmp.ICMP_ECHO_REPLY_CODE,\n+                                   csum=0,\n+                                   data=pkt_icmp.data))\n+        self.send_packet(msg.datapath, port, pkt)\n+        self.logger.info('Send ICMP echo reply to [%s].', src_ip)\n \n-        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,\n-                                  in_port=in_port, actions=actions, data=data)\n-        datapath.send_msg(out)\n \n+    def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\n+        port_mac = self.router_ports[msg.datapath.id][port]\n+\n+        offset = ethernet.ethernet._MIN_LEN\n+        end_of_data = offset + len(pkt_ipv4) + 128\n+        ip_datagram = bytearray()\n+        ip_datagram += msg.data[offset:end_of_data]\n+        data_len = int(len(ip_datagram) / 4)\n+        length_modulus = int(len(ip_datagram) % 4)\n+        if length_modulus:\n+            data_len += 1\n+            ip_datagram += bytearray([0] * (4 - length_modulus))\n+\n+        icmp_data = icmp.dest_unreach(data_len=data_len, data=ip_datagram)\n+\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\n+                                            dst=pkt_ethernet.src,\n+                                            src=port_mac))\n+        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\n+                                    src=self.router_ports_to_ip[port],\n+                                    proto=pkt_ipv4.proto))\n+        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_DEST_UNREACH,\n+                                    code=icmp.ICMP_HOST_UNREACH_CODE,\n+                                    csum=0,\n+                                    data=icmp_data))\n+        self.send_packet(msg.datapath, port, pkt)\n+\n+        self.logger.info(\"Router %s sending ICMP Destination Unreachable to %s\", msg.datapath.id, pkt_ipv4.src)\n+\n"
                },
                {
                    "date": 1652372535426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,9 +107,9 @@\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                     match=match, instructions=inst)\n         datapath.send_msg(mod)\n  \n-\n+    #Gestão de pacotes\n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def packet_in_handler(self, ev):\n         msg = ev.msg\n         dpid = msg.datapath.id        \n"
                },
                {
                    "date": 1652372557503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,9 +158,9 @@\n                     self.send_icmp_unreachable(msg, port, pkt_ethernet, pkt_ipv4)\n                     #Send ICMP network unreachable\n                    \n \n-\n+    #Enviar arp request\n     def send_arp_request(self, msg, pkt_ipv4):\n         out_port = self.ip_to_port[pkt_ipv4.dst]\n         src_mac = self.router_ports[msg.datapath.id][out_port]\n         src_ip = self.router_ports_to_ip[out_port]\n@@ -179,9 +179,9 @@\n         self.send_packet(msg.datapath,out_port,pkt)\n \n         self.logger.info(\"\\nRouter %s sending ARP Request from port %s to learn MAC of %s\", msg.datapath.id, out_port, pkt_ipv4.dst)\n \n-\n+    #Enviar pacote\n     def send_packet(self, datapath, port, pkt):\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n         pkt.serialize()\n"
                },
                {
                    "date": 1652372567959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,9 +193,9 @@\n                                   actions=actions,\n                                   data=data)\n         datapath.send_msg(out)\n \n-\n+    #Gerir arp requests\n     def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\n         #ARP packet handling.\n         dpid = msg.datapath.id\n \n"
                },
                {
                    "date": 1652372779553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,11 +85,11 @@\n         self.router_ports.setdefault(dpid, {})\n         for p in ev.msg.body:\n             self.router_ports[dpid].update({ p.port_no: p.hw_addr})\n         \n-        print(\"Router \",dpid)\n+        print(\"L3 Switches Conectado dpid:\",dpid)\n         for p in self.router_ports[dpid].keys():\n-            print(f\"Port {p} has MAC {self.router_ports[dpid][p]}\")\n+            print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\n \n         print(\"\\n\")\n \n     #Adcionar flows\n"
                },
                {
                    "date": 1652372826998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,10 @@\n             self.router_ports[dpid].update({ p.port_no: p.hw_addr})\n         \n         print(\"L3 Switches Conectado dpid:\",dpid)\n         for p in self.router_ports[dpid].keys():\n-            print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\n+            if p < 10:\n+                print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\n \n         print(\"\\n\")\n \n     #Adcionar flows\n"
                },
                {
                    "date": 1652372863909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,9 @@\n         print(\"L3 Switches Conectado dpid:\",dpid)\n         for p in self.router_ports[dpid].keys():\n             if p < 10:\n                 print(f\"Porta {p} tem endereço MAC: {self.router_ports[dpid][p]}\")\n-\n+                print(\"Cada Port Corresponde a uma subnet\")\n         print(\"\\n\")\n \n     #Adcionar flows\n     def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n"
                },
                {
                    "date": 1655541396910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+from email import parser\n from ryu.base import app_manager\n from ryu.controller import ofp_event\n from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\n from ryu.controller.handler import set_ev_cls\n@@ -264,8 +265,29 @@\n                                    csum=0,\n                                    data=pkt_icmp.data))\n         self.send_packet(msg.datapath, port, pkt)\n         self.logger.info('Send ICMP echo reply to [%s].', src_ip)\n+        \n+        match = parser.OFPMatch(in_port = port,\n+                                eth_type=0x0800,\n+                                ip_proto=pkt_ipv4.proto,\n+                                ipv4_src=pkt_ipv4.src,\n+                                ipv4_dst=pkt_ipv4.dst)\n+        \n+        #flow mods\n+        set_eth_src = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n+        set_eth_dst = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n+        set_ip_proto = parser.OFPActionSetField(ip_proto=pkt_ipv4.proto)\n+        set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\n+        set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\n+        set_icmp_type = parser.OFPActionSetField(icmpv4_type=0x00)\n+        actions = [set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, parser.OFPActionOutput(port)]\n+        \n+        self.add_flow(msg.datapath, 2, match, actions)\n+        \n+        self.logger.info(\"Entrada na flow table adicionada!\")\n+        \n+        \n \n \n     def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\n         port_mac = self.router_ports[msg.datapath.id][port]\n"
                },
                {
                    "date": 1655547072624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -273,23 +273,23 @@\n                                 ipv4_src=pkt_ipv4.src,\n                                 ipv4_dst=pkt_ipv4.dst)\n         \n         #flow mods\n+        set_csum = parser.OFPActionSetField(ipv4_csum=0)\n         set_eth_src = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n         set_eth_dst = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n         set_ip_proto = parser.OFPActionSetField(ip_proto=pkt_ipv4.proto)\n         set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\n         set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\n-        set_icmp_type = parser.OFPActionSetField(icmpv4_type=0x00)\n+        set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\n+        set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\n         actions = [set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, parser.OFPActionOutput(port)]\n         \n         self.add_flow(msg.datapath, 2, match, actions)\n         \n         self.logger.info(\"Entrada na flow table adicionada!\")\n         \n         \n-\n-\n     def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\n         port_mac = self.router_ports[msg.datapath.id][port]\n \n         offset = ethernet.ethernet._MIN_LEN\n"
                },
                {
                    "date": 1655547115613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,9 +281,9 @@\n         set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\n         set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\n         set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\n         set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\n-        actions = [set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, parser.OFPActionOutput(port)]\n+        actions = [set_csum, set_eth_src, set_eth_dest, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\n         \n         self.add_flow(msg.datapath, 2, match, actions)\n         \n         self.logger.info(\"Entrada na flow table adicionada!\")\n"
                },
                {
                    "date": 1655547121579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,9 +281,9 @@\n         set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\n         set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\n         set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\n         set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\n-        actions = [set_csum, set_eth_src, set_eth_dest, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\n+        actions = [set_csum, set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\n         \n         self.add_flow(msg.datapath, 2, match, actions)\n         \n         self.logger.info(\"Entrada na flow table adicionada!\")\n"
                },
                {
                    "date": 1655547144820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,13 +272,12 @@\n                                 ip_proto=pkt_ipv4.proto,\n                                 ipv4_src=pkt_ipv4.src,\n                                 ipv4_dst=pkt_ipv4.dst)\n         \n-        #flow mods\n+        #Inversao de endereços IPv4 e MAC para resopnder, e o tipo de código de ICMP alterados para reply.\n         set_csum = parser.OFPActionSetField(ipv4_csum=0)\n         set_eth_src = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n         set_eth_dst = parser.OFPActionSetField(eth_src=pkt_ethernet.src)\n-        set_ip_proto = parser.OFPActionSetField(ip_proto=pkt_ipv4.proto)\n         set_ip_src = parser.OFPActionSetField(ipv4_src=pkt_ipv4.src)\n         set_ip_dst = parser.OFPActionSetField(ipv4_dst=pkt_ipv4.dst)\n         set_icmp_type = parser.OFPActionSetField(icmpv4_type=0)\n         set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\n"
                },
                {
                    "date": 1655547218638,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,9 +283,16 @@\n         set_icmp_code = parser.OFPActionSetField(icmpv4_code=0)\n         actions = [set_csum, set_eth_src, set_eth_dst, set_ip_src, set_ip_dst, set_icmp_type, set_icmp_code, parser.OFPActionOutput(port)]\n         \n         self.add_flow(msg.datapath, 2, match, actions)\n+        out = msg.ofproto_parser.OFPPacketOut(datapath=msg.datapath,\n+                                              buffer_id=0xffffffff,\n+                                              in_port=msg.ofproto.OFPP_CONTROLLER,\n+                                              actions=actions,\n+                                              data=packet)\n+        msg.datapath.send_msg(out)\n         \n+        \n         self.logger.info(\"Entrada na flow table adicionada!\")\n         \n         \n     def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\n"
                }
            ],
            "date": 1652202017029,
            "name": "Commit-0",
            "content": "from ryu.base import app_manager\nfrom ryu.controller import ofp_event\nfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\nfrom ryu.controller.handler import set_ev_cls\nfrom ryu.ofproto import ofproto_v1_3\nfrom ryu.lib.packet import packet\nfrom ryu.lib.packet import ethernet\nfrom ryu.lib.packet import ether_types\nfrom ryu.lib.packet import ipv4\nfrom ryu.lib.packet import in_proto\nfrom ryu.lib.packet import icmp\nfrom ryu.lib.packet import arp\n\n\n\nclass L3Switch(app_manager.RyuApp):\n    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n\n\n    def __init__(self, *args, **kwargs):\n        super(L3Switch, self).__init__(*args, **kwargs)\n        self.mac_to_port = {}\n        self.arp_table = {\"10.0.1.254\": \"00:00:00:00:00:01\",\n            \"10.0.1.2\": \"00:00:00:00:00:02\",\n            \"10.0.1.3\": \"00:00:00:00:00:03\",\n            \"10.0.2.254\": \"00:00:00:00:00:04\",\n            \"10.0.2.2\": \"00:00:00:00:00:05\",\n            \"10.0.2.3\": \"00:00:00:00:00:06\",\n            \"10.0.3.1\": \"00:00:00:00:00:07\",\n            \"10.0.3.2\": \"00:00:00:00:00:08\",\n            \"10.0.3.3\": \"00:00:00:00:00:09\",\n}\n\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n    def switch_features_handler(self, ev):\n        datapath = ev.msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        match = parser.OFPMatch()\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                          ofproto.OFPCML_NO_BUFFER)]\n        self.add_flow(datapath, 0, match, actions)\n\n    def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                             actions)]\n        \n        if parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IPV6):\n            mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n        \n        if buffer_id:\n            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n                                    idle_timeout=500, hard_timeout=500, priority=priority, match=match,\n                                    instructions=inst)\n        else:\n            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                    idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n        datapath.send_msg(mod)\n        \n\n    \n    def arp_process(self, datapath, eth, a, in_port):\n        r = self.arp_table.get(a.dst_ip)\n        if r:\n            self.logger.info(\"Matched MAC %s \", r)\n            arp_resp = packet.Packet()\n            arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n                                    dst=eth.src, src=r))\n            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n                                    src_mac=r, src_ip=a.dst_ip,\n                                    dst_mac=a.src_mac,\n                                    dst_ip=a.src_ip))\n\n            arp_resp.serialize()\n            actions = []\n            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n            parser = datapath.ofproto_parser  \n            ofproto = datapath.ofproto\n            out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                    in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n            datapath.send_msg(out)\n            self.logger.info(\"Enviado ARP Response packet para %s\", r)\n        else: \n            print(\"Endereço não encontrado\")\n    \n    \n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n    def _packet_in_handler(self, ev):\n        # If you hit this you might want to increase\n        # the \"miss_send_length\" of your switch\n        if ev.msg.msg_len < ev.msg.total_len:\n            self.logger.debug(\"packet truncated: only %s of %s bytes\",\n                              ev.msg.msg_len, ev.msg.total_len)\n        msg = ev.msg\n        datapath = msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n        in_port = msg.match['in_port']\n\n        pkt = packet.Packet(msg.data)\n        eth = pkt.get_protocols(ethernet.ethernet)[0]\n\n        if eth.ethertype == ether_types.ETH_TYPE_LLDP:\n            # ignore lldp packet\n            return\n        dst = eth.dst\n        src = eth.src\n\n        dpid = datapath.id\n        self.mac_to_port.setdefault(dpid, {})\n\n        self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n\n        # learn a mac address to avoid FLOOD next time.\n        self.mac_to_port[dpid][src] = in_port\n        \n        #check if arp packet is received\n        if eth.ethertype == ether_types.ETH_TYPE_ARP:\n            self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n            a = pkt.get_protocol(arp.arp)\n            self.arp_process(datapath, eth, a, in_port)\n            return\n\n        if dst in self.mac_to_port[dpid]:\n            out_port = self.mac_to_port[dpid][dst]\n        else:\n            out_port = ofproto.OFPP_FLOOD\n\n        actions = [parser.OFPActionOutput(out_port)]\n\n        # install a flow to avoid packet_in next time\n        if out_port != ofproto.OFPP_FLOOD:\n\n            if eth.ethertype == ether_types.ETH_TYPE_IP:\n                ip = pkt.get_protocol(ipv4.ipv4)\n                srcip = ip.src\n                dstip = ip.dst\n                protocol = ip.proto\n                \n                if protocol == in_proto.IPPROTO_ICMP:\n                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip)\n                if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                    self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                    return\n                else:\n                    self.add_flow(datapath, 1, match, actions)\n        data = None\n        if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n            data = msg.data\n\n        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,\n                                  in_port=in_port, actions=actions, data=data)\n        datapath.send_msg(out)\n\n"
        }
    ]
}
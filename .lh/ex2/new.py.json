{
    "sourceFile": "ex2/new.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1652118465936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1652118465936,
            "name": "Commit-0",
            "content": "from ryu.base import app_manager\nfrom ryu.controller import ofp_event\nfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\nfrom ryu.controller.handler import set_ev_cls\nfrom ryu.lib.packet import arp\nfrom ryu.ofproto import ofproto_v1_4\nfrom ryu.lib.packet import packet\nfrom ryu.lib.packet import ethernet\nfrom ryu.lib.packet import ether_types\nfrom ryu.lib.packet import ipv4\nfrom ryu.lib.packet import icmp\nfrom ryu.lib.packet.arp import arp\nfrom ryu.lib.packet.packet import Packet\nimport array\n\nHOST_IPADDR1 = \"10.1.1.2\"\nHOST_IPADDR2 = \"10.1.4.2\"\nROUTER_IPADDR1 = \"10.1.1.1\"\nROUTER_IPADDR2 = \"10.1.4.1\"\nROUTER_MACADDR1 = \"00:00:00:00:00:01\"\nROUTER_MACADDR2 = \"00:00:00:00:00:02\"\nROUTER_PORT1 = 1\nROUTER_PORT2 = 2\n\nclass SimpleSwitch14(app_manager.RyuApp):\n    OFP_VERSIONS = [ofproto_v1_4.OFP_VERSION]\n\n    def __init__(self, *args, **kwargs):\n        super(SimpleSwitch14, self).__init__(*args, **kwargs)\n        self.mac_to_port = {}\n        self.arpTable = {}#ip to mac\n\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n    def switch_features_handler(self, ev):\n        datapath = ev.msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        # install table-miss flow entry\n        #\n        # We specify NO BUFFER to max_len of the output action due to\n        # OVS bug. At this moment, if we specify a lesser number, e.g.,\n        # 128, OVS will send Packet-In with invalid buffer_id and\n        # truncated packet data. In that case, we cannot output packets\n        # correctly.  The bug has been fixed in OVS v2.1.0.\n        match = parser.OFPMatch()\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                          ofproto.OFPCML_NO_BUFFER)]\n        self.add_flow(datapath, 0, match, actions)\n\n    def add_flow(self, datapath, priority, match, actions):\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                             actions)]\n\n        mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                match=match, instructions=inst)\n        datapath.send_msg(mod)\n\n    def receive_arp(self,datapath,packet,etherFrame,inPort):\n        arpPacket = packet.get_protocol(arp)\n        if arpPacket.opcode == 1 :\n            arp_dstIp = arpPacket.dst_ip\n            self.logger.debug('received ARP Request %s => %s (port%d)'%(etherFrame.src,etherFrame.dst,inPort))\n            self.reply_arp(datapath,etherFrame,arpPacket,arp_dstIp,inPort)\n        elif arpPacket.opcode == 2 :\n            pass\n\n    def reply_arp(self, datapath, etherFrame, arpPacket, arp_dstIp, inPort):\n        dstIp = arpPacket.src_ip\n        srcIp = arpPacket.dst_ip\n        dstMac = etherFrame.src\n        self.logger.debug(\"ARP dstIp: %s\"%arp_dstIp)\n        if arp_dstIp == ROUTER_IPADDR1:\n            srcMac = ROUTER_MACADDR1\n            outPort = ROUTER_PORT1\n        elif arp_dstIp == ROUTER_IPADDR2:\n            srcMac = ROUTER_MACADDR2\n            outPort = ROUTER_PORT2\n        else:\n            self.logger.debug(\"unknown arp request received !\")\n        self.send_arp(datapath, 2, srcMac, srcIp, dstMac, dstIp, outPort)\n        self.logger.debug(\"send ARP reply %s => %s (port%d)\" %(srcMac, dstMac, outPort))\n\n    def send_arp(self, datapath, opcode, srcMac, srcIp, dstMac, dstIp, outPort):\n        if opcode == 1:\n            targetMac = \"00:00:00:00:00:00\"\n            targetIp = dstIp\n        elif opcode == 2:\n            targetMac = dstMac\n            targetIp = dstIp\n        e = ethernet.ethernet(dstMac, srcMac, ether_types.ETH_TYPE_ARP)\n        a = arp(1, 0x0800, 6, 4, opcode, srcMac, srcIp, targetMac, targetIp)\n        p = Packet()\n        p.add_protocol(e)\n        p.add_protocol(a)\n        p.serialize()\n        actions = [datapath.ofproto_parser.OFPActionOutput(outPort, 0)]\n        out = datapath.ofproto_parser.OFPPacketOut(\n            datapath=datapath,\n            buffer_id=0xffffffff,\n            in_port=datapath.ofproto.OFPP_CONTROLLER,\n            actions=actions,\n            data=p.data)\n        datapath.send_msg(out)\n\n    def _send_packet(self, datapath, port, pkt):\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n        pkt.serialize()\n        self.logger.info(\"packet-out %s\" % (pkt,))\n        data = pkt.data\n        actions = [parser.OFPActionOutput(port=port)]\n        out = parser.OFPPacketOut(datapath=datapath,\n                                  buffer_id=ofproto.OFP_NO_BUFFER,\n                                  in_port=ofproto.OFPP_CONTROLLER,\n                                  actions=actions,\n                                  data=data)\n        datapath.send_msg(out)\n\n    def _handle_icmp(self, datapath, port, pkt_ethernet, pkt_ipv4, pkt_icmp):\n        if pkt_icmp.type != icmp.ICMP_ECHO_REQUEST:\n            return\n        pkt = packet.Packet()\n        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\n                                           dst=pkt_ethernet.src,\n                                           src=ROUTER_MACADDR1))\n        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\n                                   src=ROUTER_IPADDR1,\n                                   proto=pkt_ipv4.proto))\n        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\n                                   code=icmp.ICMP_ECHO_REPLY_CODE,\n                                   csum=0,\n                                   data=pkt_icmp.data))\n        self._send_packet(datapath, port, pkt)\n\n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n    def _packet_in_handler(self, ev):\n        msg = ev.msg\n        datapath = msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n        in_port = msg.match['in_port']\n        pkt = packet.Packet(msg.data)\n        eth = pkt.get_protocols(ethernet.ethernet)[0]\n        self.logger.info('%s'%eth.ethertype)\n        dst = eth.dst\n        src = eth.src\n        dpid = datapath.id\n        self.mac_to_port.setdefault(dpid, {})\n\n        if eth.ethertype == ether_types.ETH_TYPE_LLDP:\n            # ignore lldp packet\n            return\n        self.logger.info(\"packet in dpid: %s, srce: %s, dest: %s, in_port: %s\", dpid, src, dst, in_port)\n        # learn a mac address to avoid FLOOD next time.\n        self.mac_to_port[dpid][src] = in_port\n        if eth.ethertype == ether_types.ETH_TYPE_ARP:\n            self.receive_arp(datapath,pkt,eth,in_port)\n        #learn mac to ip \n        if eth.ethertype == ether_types.ETH_TYPE_IP:\n            ipv4_pak = pkt.get_protocol(ipv4.ipv4)\n            icmp_pak = pkt.get_protocol(icmp.icmp)\n            self.logger.info('packet_in_handler: --> %s'%ipv4_pak)\n            if dst == ROUTER_MACADDR1:\n                out_port = 2\n                actions.append( OFPActionSetField(eth_src=ROUTER_MACADDR2) )\n                actions.append( OFPActionSetField(eth_dst='b2:64:b7:5f:5a:97') )\n\n            elif dst == ROUTER_MACADDR2:\n                out_port = 1\n                actions.append( OFPActionSetField(eth_src=ROUTER_MACADDR1) )\n                actions.append( OFPActionSetField(eth_dst='a2:86:fb:29:dc:57 ') )\n            else:\n                self.logger.info('Not working')\n                return\n            out = parser.OFPPacketOut(datapath = datapath,\n                                      buffer_id = ofproto.OFP_NO_BUFFER,\n                                      in_port = in_port,\n                                      actions = actions,\n                                      data = msg.data)\n            self.logger.info('packet_out:--> %s'%out)\n            datapath.send_msg(out)"
        }
    ]
}
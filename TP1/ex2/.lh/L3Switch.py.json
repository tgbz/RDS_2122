{
    "sourceFile": "L3Switch.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 44,
            "patches": [
                {
                    "date": 1652275889062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1652275981489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,8 +80,9 @@\n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n+        print(self.mac_to_port)\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n         if ev.msg.msg_len < ev.msg.total_len:\n             self.logger.debug(\"packet truncated: only %s of %s bytes\",\n"
                },
                {
                    "date": 1652279940609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,12 @@\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n-            print(\"Endereço não encontrado\")\n+            print(\"Endereço não encontrado, a adicionar à tabela\")\n+            arp_resp = packet.Packet()\n+            print(arp_resp)\n+            \n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n"
                },
                {
                    "date": 1652279997723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,12 @@\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             print(\"Endereço não encontrado, a adicionar à tabela\")\n             arp_resp = packet.Packet()\n+            print(\"Arp response\")\n             print(arp_resp)\n+            print(\"datapath:\")\n+            print(datapath)\n             \n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n"
                },
                {
                    "date": 1652280168073,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,13 +77,10 @@\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             print(\"Endereço não encontrado, a adicionar à tabela\")\n             arp_resp = packet.Packet()\n-            print(\"Arp response\")\n-            print(arp_resp)\n-            print(\"datapath:\")\n-            print(datapath)\n             \n+            \n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n"
                },
                {
                    "date": 1652280274155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,12 +75,13 @@\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n-            print(\"Endereço não encontrado, a adicionar à tabela\")\n-            arp_resp = packet.Packet()\n+            #if ip address not in arp table, send arp request\n+            self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n+            arp_req = packet.Packet()\n+            print(a)\n             \n-            \n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n"
                },
                {
                    "date": 1652280295172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n         else: \n             #if ip address not in arp table, send arp request\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n-            print(a)\n+            print(\"source ip %s, \\n destination ip %s\", a.src_ip, a.dst_ip)\n             \n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n"
                },
                {
                    "date": 1652280718766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n         #check if arp packet is received\n         if eth.ethertype == ether_types.ETH_TYPE_ARP:\n             self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n             a = pkt.get_protocol(arp.arp)\n-            self.arp_process(datapath, eth, a, in_port)\n+            self.arp_process(datapath, eth, a, src, dst, in_port)\n             return\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n"
                },
                {
                    "date": 1652280733306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n         datapath.send_msg(mod)\n         \n \n     \n-    def arp_process(self, datapath, eth, a, in_port):\n+    def arp_process(self, datapath, eth, a, macsrc, macdst, in_port):\n         r = self.arp_table.get(a.dst_ip)\n         if r:\n             self.logger.info(\"Matched MAC %s \", r)\n             arp_resp = packet.Packet()\n"
                },
                {
                    "date": 1652280765039,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,8 +76,9 @@\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n+            self.arp_table.add(a.src_ip, macsrc)\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n             print(\"source ip %s, \\n destination ip %s\", a.src_ip, a.dst_ip)\n             \n"
                },
                {
                    "date": 1652281208584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,8 +77,9 @@\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n             self.arp_table.add(a.src_ip, macsrc)\n+            print(arp_table)\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n             print(\"source ip %s, \\n destination ip %s\", a.src_ip, a.dst_ip)\n             \n"
                },
                {
                    "date": 1652281223203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,10 @@\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n             self.arp_table.add(a.src_ip, macsrc)\n-            print(arp_table)\n+            print(\"arp table:\")\n+            print(self.arp_table)\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n             print(\"source ip %s, \\n destination ip %s\", a.src_ip, a.dst_ip)\n             \n"
                },
                {
                    "date": 1652281305933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,15 @@\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                     idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n         datapath.send_msg(mod)\n         \n+        \n+    #method to add ip:macaddress to arp table\n+    def add_arp_table(self, ip, mac):\n+        self.arp_table.add(ip, mac)\n+        print(\"arp table:\")\n+        print(self.arp_table)\n+    \n \n     \n     def arp_process(self, datapath, eth, a, macsrc, macdst, in_port):\n         r = self.arp_table.get(a.dst_ip)\n"
                },
                {
                    "date": 1652281344265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,14 +52,13 @@\n                                     idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n         datapath.send_msg(mod)\n         \n         \n-    #method to add ip:macaddress to arp table\n+    #method to add ip:macaddress to arp table dict\n     def add_arp_table(self, ip, mac):\n-        self.arp_table.add(ip, mac)\n-        print(\"arp table:\")\n-        print(self.arp_table)\n-    \n+        self.arp_table[ip] = mac\n+        self.logger.info(\"Added %s:%s to ARP table\", ip, mac)\n+       \n \n     \n     def arp_process(self, datapath, eth, a, macsrc, macdst, in_port):\n         r = self.arp_table.get(a.dst_ip)\n@@ -83,11 +82,9 @@\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n-            self.arp_table.add(a.src_ip, macsrc)\n-            print(\"arp table:\")\n-            print(self.arp_table)\n+            \n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n             print(\"source ip %s, \\n destination ip %s\", a.src_ip, a.dst_ip)\n             \n"
                },
                {
                    "date": 1652281365996,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,13 +52,10 @@\n                                     idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n         datapath.send_msg(mod)\n         \n         \n-    #method to add ip:macaddress to arp table dict\n-    def add_arp_table(self, ip, mac):\n-        self.arp_table[ip] = mac\n-        self.logger.info(\"Added %s:%s to ARP table\", ip, mac)\n-       \n+    #method to add ip:macaddress to arp table\n+    \n \n     \n     def arp_process(self, datapath, eth, a, macsrc, macdst, in_port):\n         r = self.arp_table.get(a.dst_ip)\n@@ -82,9 +79,11 @@\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n-            \n+            self.arp_table.[a.src_ip]= macsrc\n+            print(\"arp table:\")\n+            print(self.arp_table)\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n             print(\"source ip %s, \\n destination ip %s\", a.src_ip, a.dst_ip)\n             \n"
                },
                {
                    "date": 1652281372406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n-            self.arp_table.[a.src_ip]= macsrc\n+            self.arp_table[a.src_ip]=macsrc\n             print(\"arp table:\")\n             print(self.arp_table)\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n"
                },
                {
                    "date": 1652281417209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n             print(\"arp table:\")\n             print(self.arp_table)\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n-            print(\"source ip %s, \\n destination ip %s\", a.src_ip, a.dst_ip)\n+            print(\"source ip %s , \\n destination ip %s\", a.src_ip, a.dst_ip)\n             \n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n"
                },
                {
                    "date": 1652281486319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,14 +79,14 @@\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n-            self.arp_table[a.src_ip]=macsrc\n+            self.arp_table[macsrc]=a.src_ip\n             print(\"arp table:\")\n             print(self.arp_table)\n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n-            print(\"source ip %s , \\n destination ip %s\", a.src_ip, a.dst_ip)\n+            print(\"source ip %s destination ip %s\", a.src_ip, a.dst_ip)\n             \n     \n     \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n"
                },
                {
                    "date": 1652281780908,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,8 +82,25 @@\n             #if ip address not in arp table, send arp request\n             self.arp_table[macsrc]=a.src_ip\n             print(\"arp table:\")\n             print(self.arp_table)\n+            arp_resp = packet.Packet()\n+            arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n+                                    dst=eth.src, src=a.dest_ip))\n+            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n+                                    src_mac=macsrc, src_ip=a.dst_ip,\n+                                    dst_mac=a.src_mac,\n+                                    dst_ip=a.src_ip))\n+\n+            arp_resp.serialize()\n+            actions = []\n+            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n+            parser = datapath.ofproto_parser  \n+            ofproto = datapath.ofproto\n+            out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n+                                    in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n+            datapath.send_msg(out)\n+            \n             self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             arp_req = packet.Packet()\n             print(\"source ip %s destination ip %s\", a.src_ip, a.dst_ip)\n             \n"
                },
                {
                    "date": 1652281797371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,10 +79,11 @@\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n+            self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n             self.arp_table[macsrc]=a.src_ip\n-            print(\"arp table:\")\n+            print(\"arp table status:\")\n             print(self.arp_table)\n             arp_resp = packet.Packet()\n             arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n                                     dst=eth.src, src=a.dest_ip))\n@@ -99,9 +100,9 @@\n             out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n             \n-            self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n+            \n             arp_req = packet.Packet()\n             print(\"source ip %s destination ip %s\", a.src_ip, a.dst_ip)\n             \n     \n"
                },
                {
                    "date": 1652281803116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,11 +99,9 @@\n             ofproto = datapath.ofproto\n             out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                     in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n             datapath.send_msg(out)\n-            \n-            \n-            arp_req = packet.Packet()\n+        \n             print(\"source ip %s destination ip %s\", a.src_ip, a.dst_ip)\n             \n     \n     \n"
                },
                {
                    "date": 1652281894647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,9 +85,9 @@\n             print(\"arp table status:\")\n             print(self.arp_table)\n             arp_resp = packet.Packet()\n             arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n-                                    dst=eth.src, src=a.dest_ip))\n+                                    dst=eth.src, src=macdst))\n             arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n                                     src_mac=macsrc, src_ip=a.dst_ip,\n                                     dst_mac=a.src_mac,\n                                     dst_ip=a.src_ip))\n"
                },
                {
                    "date": 1652281954320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n             datapath.send_msg(out)\n             self.logger.info(\"Enviado ARP Response packet para %s\", r)\n         else: \n             #if ip address not in arp table, send arp request\n-            self.logger.info(\"No match found for MAC %s\", a.dst_ip)\n+            self.logger.info(\"No match found for MAC for ip %s\", a.dst_ip)\n             self.arp_table[macsrc]=a.src_ip\n             print(\"arp table status:\")\n             print(self.arp_table)\n             arp_resp = packet.Packet()\n"
                },
                {
                    "date": 1652282006910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,10 +87,10 @@\n             arp_resp = packet.Packet()\n             arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n                                     dst=eth.src, src=macdst))\n             arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n-                                    src_mac=macsrc, src_ip=a.dst_ip,\n-                                    dst_mac=a.src_mac,\n+                                    src_mac=macsrc, src_ip=a.src_ip,\n+                                    dst_mac=a.dst_mac,\n                                     dst_ip=a.src_ip))\n \n             arp_resp.serialize()\n             actions = []\n"
                },
                {
                    "date": 1652282226459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n             arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n                                     src_mac=macsrc, src_ip=a.src_ip,\n                                     dst_mac=a.dst_mac,\n                                     dst_ip=a.src_ip))\n-\n+            print(\"Enviado ARP Request para \")\n             arp_resp.serialize()\n             actions = []\n             actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n             parser = datapath.ofproto_parser  \n@@ -102,10 +102,27 @@\n             datapath.send_msg(out)\n         \n             print(\"source ip %s destination ip %s\", a.src_ip, a.dst_ip)\n             \n+    #function to send arp requests\n+    def arp_request(self, datapath, in_port, src_mac, src_ip, dst_ip):\n+        arp_req = packet.Packet()\n+        arp_req.add_protocol(ethernet.ethernet(ethertype=ether_types.ETH_TYPE_ARP,\n+                                    dst=\"ff:ff:ff:ff:ff:ff\", src=src_mac))\n+        arp_req.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\n+                                    src_mac=src_mac, src_ip=src_ip,\n+                                    dst_mac=\"00:00:00:00:00:00\",\n+                                    dst_ip=dst_ip))\n+        arp_req.serialize()\n+        actions = []\n+        actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n+        parser = datapath.ofproto_parser\n+        ofproto = datapath.ofproto\n+        out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n+                                in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_req)\n+        datapath.send_msg(out)\n+        self.logger.info(\"Enviado ARP Request para %s\", dst_ip)\n     \n-    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         print(self.mac_to_port)\n         # If you hit this you might want to increase\n"
                },
                {
                    "date": 1652282285554,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,11 +9,11 @@\n from ryu.lib.packet import ipv4\n from ryu.lib.packet import in_proto\n from ryu.lib.packet import icmp\n from ryu.lib.packet import arp\n+import time\n \n \n-\n class L3Switch(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n \n@@ -121,8 +121,30 @@\n                                 in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_req)\n         datapath.send_msg(out)\n         self.logger.info(\"Enviado ARP Request para %s\", dst_ip)\n     \n+    #function to wait for arp reply\n+    def arp_wait(self, datapath, in_port, src_mac, src_ip, dst_ip):\n+        arp_req = packet.Packet()\n+        arp_req.add_protocol(ethernet.ethernet(ethertype=ether_types.ETH_TYPE_ARP,\n+                                    dst=\"ff:ff:ff:ff:ff:ff\", src=src_mac))\n+        arp_req.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\n+                                    src_mac=src_mac, src_ip=src_ip,\n+                                    dst_mac=\"00:00:00:00:00:00\",\n+                                    dst_ip=dst_ip))\n+        arp_req.serialize()\n+        actions = []\n+        actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n+        parser = datapath.ofproto_parser\n+        ofproto = datapath.ofproto\n+        out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n+                                in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_req)\n+        datapath.send_msg(out)\n+        self.logger.info(\"Enviado ARP Request para %s\", dst_ip)\n+        time.sleep(1)\n+        self.arp_wait(datapath, in_port, src_mac, src_ip, dst_ip)\n+    \n+    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         print(self.mac_to_port)\n         # If you hit this you might want to increase\n"
                },
                {
                    "date": 1652284474009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,49 +102,9 @@\n             datapath.send_msg(out)\n         \n             print(\"source ip %s destination ip %s\", a.src_ip, a.dst_ip)\n             \n-    #function to send arp requests\n-    def arp_request(self, datapath, in_port, src_mac, src_ip, dst_ip):\n-        arp_req = packet.Packet()\n-        arp_req.add_protocol(ethernet.ethernet(ethertype=ether_types.ETH_TYPE_ARP,\n-                                    dst=\"ff:ff:ff:ff:ff:ff\", src=src_mac))\n-        arp_req.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\n-                                    src_mac=src_mac, src_ip=src_ip,\n-                                    dst_mac=\"00:00:00:00:00:00\",\n-                                    dst_ip=dst_ip))\n-        arp_req.serialize()\n-        actions = []\n-        actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n-        parser = datapath.ofproto_parser\n-        ofproto = datapath.ofproto\n-        out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n-                                in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_req)\n-        datapath.send_msg(out)\n-        self.logger.info(\"Enviado ARP Request para %s\", dst_ip)\n     \n-    #function to wait for arp reply\n-    def arp_wait(self, datapath, in_port, src_mac, src_ip, dst_ip):\n-        arp_req = packet.Packet()\n-        arp_req.add_protocol(ethernet.ethernet(ethertype=ether_types.ETH_TYPE_ARP,\n-                                    dst=\"ff:ff:ff:ff:ff:ff\", src=src_mac))\n-        arp_req.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\n-                                    src_mac=src_mac, src_ip=src_ip,\n-                                    dst_mac=\"00:00:00:00:00:00\",\n-                                    dst_ip=dst_ip))\n-        arp_req.serialize()\n-        actions = []\n-        actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n-        parser = datapath.ofproto_parser\n-        ofproto = datapath.ofproto\n-        out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n-                                in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_req)\n-        datapath.send_msg(out)\n-        self.logger.info(\"Enviado ARP Request para %s\", dst_ip)\n-        time.sleep(1)\n-        self.arp_wait(datapath, in_port, src_mac, src_ip, dst_ip)\n-    \n-    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         print(self.mac_to_port)\n         # If you hit this you might want to increase\n@@ -167,9 +127,9 @@\n         dst = eth.dst\n         src = eth.src\n \n         dpid = datapath.id\n-        self.mac_to_port.setdefault(dpid, {})\n+        \n \n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n"
                },
                {
                    "date": 1652284668653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n \n     def __init__(self, *args, **kwargs):\n         super(L3Switch, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n-        self.arp_table = {}\n+        self.arp_table = dict()\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n@@ -127,9 +127,9 @@\n         dst = eth.dst\n         src = eth.src\n \n         dpid = datapath.id\n-        \n+        self.mac_to_port.setdefault(dpid, {})\n \n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n"
                },
                {
                    "date": 1652285871653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,27 +8,30 @@\n from ryu.lib.packet import ether_types\n from ryu.lib.packet import ipv4\n from ryu.lib.packet import in_proto\n from ryu.lib.packet import icmp\n-from ryu.lib.packet import arp\n-import time\n \n \n class L3Switch(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n-\n     def __init__(self, *args, **kwargs):\n         super(L3Switch, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n-        self.arp_table = dict()\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n \n+        # install table-miss flow entry\n+        #\n+        # We specify NO BUFFER to max_len of the output action due to\n+        # OVS bug. At this moment, if we specify a lesser number, e.g.,\n+        # 128, OVS will send Packet-In with invalid buffer_id and\n+        # truncated packet data. In that case, we cannot output packets\n+        # correctly.  The bug has been fixed in OVS v2.1.0.\n         match = parser.OFPMatch()\n         actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                           ofproto.OFPCML_NO_BUFFER)]\n         self.add_flow(datapath, 0, match, actions)\n@@ -38,76 +41,19 @@\n         parser = datapath.ofproto_parser\n \n         inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                              actions)]\n-        \n-        if parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IPV6):\n-            mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n-        \n         if buffer_id:\n             mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n-                                    idle_timeout=500, hard_timeout=500, priority=priority, match=match,\n+                                    priority=priority, match=match,\n                                     instructions=inst)\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n-                                    idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n+                                    match=match, instructions=inst)\n         datapath.send_msg(mod)\n-        \n-        \n-    #method to add ip:macaddress to arp table\n-    \n \n-    \n-    def arp_process(self, datapath, eth, a, macsrc, macdst, in_port):\n-        r = self.arp_table.get(a.dst_ip)\n-        if r:\n-            self.logger.info(\"Matched MAC %s \", r)\n-            arp_resp = packet.Packet()\n-            arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n-                                    dst=eth.src, src=r))\n-            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n-                                    src_mac=r, src_ip=a.dst_ip,\n-                                    dst_mac=a.src_mac,\n-                                    dst_ip=a.src_ip))\n-\n-            arp_resp.serialize()\n-            actions = []\n-            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n-            parser = datapath.ofproto_parser  \n-            ofproto = datapath.ofproto\n-            out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n-                                    in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n-            datapath.send_msg(out)\n-            self.logger.info(\"Enviado ARP Response packet para %s\", r)\n-        else: \n-            #if ip address not in arp table, send arp request\n-            self.logger.info(\"No match found for MAC for ip %s\", a.dst_ip)\n-            self.arp_table[macsrc]=a.src_ip\n-            print(\"arp table status:\")\n-            print(self.arp_table)\n-            arp_resp = packet.Packet()\n-            arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n-                                    dst=eth.src, src=macdst))\n-            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n-                                    src_mac=macsrc, src_ip=a.src_ip,\n-                                    dst_mac=a.dst_mac,\n-                                    dst_ip=a.src_ip))\n-            print(\"Enviado ARP Request para \")\n-            arp_resp.serialize()\n-            actions = []\n-            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n-            parser = datapath.ofproto_parser  \n-            ofproto = datapath.ofproto\n-            out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n-                                    in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n-            datapath.send_msg(out)\n-        \n-            print(\"source ip %s destination ip %s\", a.src_ip, a.dst_ip)\n-            \n-    \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n-        print(self.mac_to_port)\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n         if ev.msg.msg_len < ev.msg.total_len:\n             self.logger.debug(\"packet truncated: only %s of %s bytes\",\n@@ -133,15 +79,8 @@\n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n         self.mac_to_port[dpid][src] = in_port\n-        \n-        #check if arp packet is received\n-        if eth.ethertype == ether_types.ETH_TYPE_ARP:\n-            self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n-            a = pkt.get_protocol(arp.arp)\n-            self.arp_process(datapath, eth, a, src, dst, in_port)\n-            return\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n         else:\n@@ -151,25 +90,31 @@\n \n         # install a flow to avoid packet_in next time\n         if out_port != ofproto.OFPP_FLOOD:\n \n+            # check IP Protocol and create a match for IP\n             if eth.ethertype == ether_types.ETH_TYPE_IP:\n                 ip = pkt.get_protocol(ipv4.ipv4)\n                 srcip = ip.src\n                 dstip = ip.dst\n-                protocol = ip.proto\n+                protocol = ip.proto \n+                # verify if we have a valid buffer_id, if yes avoid to send both\n+                # flow_mod & packet_out\n+               \n+               \n+               #IF ICMP\n+                if protocol == in_proto.IPPROTO_ICMP:\n+                   match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP,ipv4_src=srcip,ipv4_dst=dstip,ip_proto=protocol)\n                 \n-                if protocol == in_proto.IPPROTO_ICMP:\n-                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip)\n                 if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                     self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                     return\n                 else:\n-                    self.add_flow(datapath, 1, match, actions)\n+                    self.add_flow(datapath,1,match,actions)\n+               \n         data = None\n         if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n             data = msg.data\n \n         out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,\n                                   in_port=in_port, actions=actions, data=data)\n         datapath.send_msg(out)\n-\n"
                },
                {
                    "date": 1652286028980,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,10 +102,11 @@\n                \n                \n                #IF ICMP\n                 if protocol == in_proto.IPPROTO_ICMP:\n+                   print(\"Pacote ICMP detectado!\")\n                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP,ipv4_src=srcip,ipv4_dst=dstip,ip_proto=protocol)\n-                \n+\n                 if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                     self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                     return\n                 else:\n"
                },
                {
                    "date": 1652286108206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,9 +95,13 @@\n             if eth.ethertype == ether_types.ETH_TYPE_IP:\n                 ip = pkt.get_protocol(ipv4.ipv4)\n                 srcip = ip.src\n                 dstip = ip.dst\n-                protocol = ip.proto \n+                protocol = ip.proto\n+                #print srcip dstip protocol\n+                print(\"IP:\", srcip, dstip, protocol)\n+                \n+                 \n                 # verify if we have a valid buffer_id, if yes avoid to send both\n                 # flow_mod & packet_out\n                \n                \n"
                },
                {
                    "date": 1652286563845,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,8 +16,9 @@\n \n     def __init__(self, *args, **kwargs):\n         super(L3Switch, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n+        self.arp_table = dict()\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n@@ -50,8 +51,21 @@\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                     match=match, instructions=inst)\n         datapath.send_msg(mod)\n \n+    def arp_handler(self,datapath,eth,a,in_port):\n+        #tentar encontrar match na arp table\n+        r = self.arp_table.get(a.dest_ip)\n+        if r:\n+            self.logger.info(\"MAC encontrado %s\")\n+            arp_resp = packet.Packet()\n+            arp_resp.add_protocol(ethernet.ethernet(dst=eth.src,src=r))\n+            \n+            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n+                                  src_mac=r, src_ip=a.dst_ip,\n+                                  dst_mac=a.src_mac,\n+                                  dst_ip=a.src_ip))\n+\n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n"
                },
                {
                    "date": 1652286623330,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n from ryu.lib.packet import ether_types\n from ryu.lib.packet import ipv4\n from ryu.lib.packet import in_proto\n from ryu.lib.packet import icmp\n+from ryu.lib.packet import arp\n \n \n class L3Switch(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n@@ -59,13 +60,11 @@\n             self.logger.info(\"MAC encontrado %s\")\n             arp_resp = packet.Packet()\n             arp_resp.add_protocol(ethernet.ethernet(dst=eth.src,src=r))\n             \n-            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n-                                  src_mac=r, src_ip=a.dst_ip,\n-                                  dst_mac=a.src_mac,\n-                                  dst_ip=a.src_ip))\n-\n+            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,src_mac=r,src_ip=a.dst_ip,dst_mac=a.src_mac,dst_ip=a.src_ip))\n+        \n+        \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n"
                },
                {
                    "date": 1652286701856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,10 +61,20 @@\n             arp_resp = packet.Packet()\n             arp_resp.add_protocol(ethernet.ethernet(dst=eth.src,src=r))\n             \n             arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,src_mac=r,src_ip=a.dst_ip,dst_mac=a.src_mac,dst_ip=a.src_ip))\n+            \n+            arp_resp.serialize()\n+            \n+            actions = []\n+            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n+            parser = datapath.ofproto_parser\n+            ofproto = datapath.ofproto\n+            out = parser.OFPPacketOut(datapath=datapath,buffer_id=ofproto.OFP_NO_BUFFER,in_port=ofproto.OFPP_CONTROLLER,actions=actions,data=arp_resp)\n+\n+            datapath.send_msg(out)\n+            self.logger.info(\"Pacote ARP enviado\")\n         \n-        \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n"
                },
                {
                    "date": 1652286795609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,8 @@\n \n     def __init__(self, *args, **kwargs):\n         super(L3Switch, self).__init__(*args, **kwargs)\n         self.mac_to_port = {}\n-        self.arp_table = dict()\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n@@ -72,11 +71,15 @@\n             out = parser.OFPPacketOut(datapath=datapath,buffer_id=ofproto.OFP_NO_BUFFER,in_port=ofproto.OFPP_CONTROLLER,actions=actions,data=arp_resp)\n \n             datapath.send_msg(out)\n             self.logger.info(\"Pacote ARP enviado\")\n+\n         \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n+        print(\"new Packet\")\n+        print(\"current mac table:\")\n+        print(self.mac_to_port)\n         # If you hit this you might want to increase\n         # the \"miss_send_length\" of your switch\n         if ev.msg.msg_len < ev.msg.total_len:\n             self.logger.debug(\"packet truncated: only %s of %s bytes\",\n"
                },
                {
                    "date": 1652286836859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n     def __init__(self, *args, **kwargs):\n         super(L3Switch, self).__init__(*args, **kwargs)\n-        self.mac_to_port = {}\n+        self.mac_to_port = {0:'fakeMAC'}\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n"
                },
                {
                    "date": 1652286885404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,9 @@\n         dst = eth.dst\n         src = eth.src\n \n         dpid = datapath.id\n-        self.mac_to_port.setdefault(dpid, {})\n+        \n \n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n"
                },
                {
                    "date": 1652286962212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,18 @@\n \n             datapath.send_msg(out)\n             self.logger.info(\"Pacote ARP enviado\")\n \n+    \n+    #function to add new entry to mac_to_port table,\n+    # if there already an entry with the same port, add the new mac to the list of entrys\n+    def add_mac_to_port(self,mac,port):\n+        if port in self.mac_to_port:\n+            self.mac_to_port[port].append(mac)\n+        else:\n+            self.mac_to_port[port] = [mac]\n         \n+        \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         print(\"new Packet\")\n         print(\"current mac table:\")\n"
                },
                {
                    "date": 1652287000732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,10 +80,10 @@\n         if port in self.mac_to_port:\n             self.mac_to_port[port].append(mac)\n         else:\n             self.mac_to_port[port] = [mac]\n+        self.logger.info(\"MAC %s adicionado a porta %s\",mac,port)\n         \n-        \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         print(\"new Packet\")\n         print(\"current mac table:\")\n@@ -113,9 +113,10 @@\n \n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n-        self.mac_to_port[dpid][src] = in_port\n+        self.add_mac_to_port(dpid,src)\n+        #self.mac_to_port[dpid][src] = in_port\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n         else:\n"
                },
                {
                    "date": 1652287124298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,9 +113,9 @@\n \n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n-        self.add_mac_to_port(dpid,src)\n+        self.add_mac_to_port(dpid,src,in_port)\n         #self.mac_to_port[dpid][src] = in_port\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n"
                },
                {
                    "date": 1652287171694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,9 +113,9 @@\n \n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n-        self.add_mac_to_port(dpid,src,in_port)\n+        self.add_mac_to_port(src,dpid)\n         #self.mac_to_port[dpid][src] = in_port\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n"
                },
                {
                    "date": 1652287232374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n     def __init__(self, *args, **kwargs):\n         super(L3Switch, self).__init__(*args, **kwargs)\n-        self.mac_to_port = {0:'fakeMAC'}\n+        self.mac_to_port = {}\n \n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n@@ -72,17 +72,8 @@\n \n             datapath.send_msg(out)\n             self.logger.info(\"Pacote ARP enviado\")\n \n-    \n-    #function to add new entry to mac_to_port table,\n-    # if there already an entry with the same port, add the new mac to the list of entrys\n-    def add_mac_to_port(self,mac,port):\n-        if port in self.mac_to_port:\n-            self.mac_to_port[port].append(mac)\n-        else:\n-            self.mac_to_port[port] = [mac]\n-        self.logger.info(\"MAC %s adicionado a porta %s\",mac,port)\n         \n     @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n     def _packet_in_handler(self, ev):\n         print(\"new Packet\")\n@@ -108,15 +99,14 @@\n         dst = eth.dst\n         src = eth.src\n \n         dpid = datapath.id\n-        \n+        self.mac_to_port.setdefault(dpid, {})\n \n         self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n \n         # learn a mac address to avoid FLOOD next time.\n-        self.add_mac_to_port(src,dpid)\n-        #self.mac_to_port[dpid][src] = in_port\n+        self.mac_to_port[dpid][src] = in_port\n \n         if dst in self.mac_to_port[dpid]:\n             out_port = self.mac_to_port[dpid][dst]\n         else:\n"
                },
                {
                    "date": 1652289770105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,41 +3,85 @@\n from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\n from ryu.controller.handler import set_ev_cls\n from ryu.ofproto import ofproto_v1_3\n from ryu.lib.packet import packet\n+from ryu.lib.packet import ether_types\n+from ryu.lib.packet import packet_base\n from ryu.lib.packet import ethernet\n-from ryu.lib.packet import ether_types\n+from ryu.lib.packet import arp\n+from ryu.lib.packet import ethernet\n+from ryu.lib.packet import icmp\n from ryu.lib.packet import ipv4\n-from ryu.lib.packet import in_proto\n-from ryu.lib.packet import icmp\n-from ryu.lib.packet import arp\n+from ryu.lib.packet import packet\n+from ryu.lib.packet import packet_base\n+from ryu.lib.packet import tcp\n+from ryu.lib.packet import udp\n+from ryu.ofproto import ether\n \n+ETHERNET = ethernet.ethernet.__name__\n+IPV4 = ipv4.ipv4.__name__\n+ARP = arp.arp.__name__\n+ICMP = icmp.icmp.__name__\n+TCP = tcp.tcp.__name__\n+UDP = udp.udp.__name__\n \n-class L3Switch(app_manager.RyuApp):\n+\n+\n+\n+class SwitchL3(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n     def __init__(self, *args, **kwargs):\n-        super(L3Switch, self).__init__(*args, **kwargs)\n-        self.mac_to_port = {}\n+        super(SwitchL3, self).__init__(*args, **kwargs)\n+        self.ip_to_mac = {}\n+        self.ip_to_port = {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1,\n+                           '10.0.2.2' : 2, '10.0.2.3' : 2, '10.0.2.4' : 2,\n+                           '10.0.3.2' : 3, '10.0.3.3' : 3, '10.0.3.4' : 3,}\n+        self.router_ports = {}\n+        self.router_ports_to_ip = {1 : '10.0.1.1', 2 : '10.0.2.1', 3 : '10.0.3.1'}\n+        \n+        self.packet_queue = {}\n \n+\n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n \n-        # install table-miss flow entry\n-        #\n-        # We specify NO BUFFER to max_len of the output action due to\n-        # OVS bug. At this moment, if we specify a lesser number, e.g.,\n-        # 128, OVS will send Packet-In with invalid buffer_id and\n-        # truncated packet data. In that case, we cannot output packets\n-        # correctly.  The bug has been fixed in OVS v2.1.0.\n         match = parser.OFPMatch()\n-        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n-                                          ofproto.OFPCML_NO_BUFFER)]\n+        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]\n+\n         self.add_flow(datapath, 0, match, actions)\n \n+        match = parser.OFPMatch(eth_type = ether_types.ETH_TYPE_IPV6)\n+        actions = []\n+\n+        self.add_flow(datapath, 1, match, actions)\n+        self.port_desc(datapath)\n+\n+\n+    def port_desc(self, datapath):\n+        ofparser = datapath.ofproto_parser\n+\n+        req = ofparser.OFPPortDescStatsRequest(datapath,0)\n+        datapath.send_msg(req)\n+\n+\n+    @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\n+    def port_desc_stats_reply_handle(self,ev):\n+\n+        dpid = ev.msg.datapath.id\n+        self.router_ports.setdefault(dpid, {})\n+        for p in ev.msg.body:\n+            self.router_ports[dpid].update({ p.port_no: p.hw_addr})\n+        \n+        print(\"Router \",dpid)\n+        for p in self.router_ports[dpid].keys():\n+            print(f\"Port {p} has MAC {self.router_ports[dpid][p]}\")\n+\n+        print(\"\\n\")\n+\n     def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n \n@@ -50,102 +94,193 @@\n         else:\n             mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                     match=match, instructions=inst)\n         datapath.send_msg(mod)\n+ \n \n-    def arp_handler(self,datapath,eth,a,in_port):\n-        #tentar encontrar match na arp table\n-        r = self.arp_table.get(a.dest_ip)\n-        if r:\n-            self.logger.info(\"MAC encontrado %s\")\n-            arp_resp = packet.Packet()\n-            arp_resp.add_protocol(ethernet.ethernet(dst=eth.src,src=r))\n-            \n-            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,src_mac=r,src_ip=a.dst_ip,dst_mac=a.src_mac,dst_ip=a.src_ip))\n-            \n-            arp_resp.serialize()\n-            \n-            actions = []\n-            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n-            parser = datapath.ofproto_parser\n-            ofproto = datapath.ofproto\n-            out = parser.OFPPacketOut(datapath=datapath,buffer_id=ofproto.OFP_NO_BUFFER,in_port=ofproto.OFPP_CONTROLLER,actions=actions,data=arp_resp)\n+    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n+    def packet_in_handler(self, ev):\n+        msg = ev.msg\n+        dpid = msg.datapath.id        \n+        port = msg.match['in_port']\n+        pkt = packet.Packet(msg.data)\n \n-            datapath.send_msg(out)\n-            self.logger.info(\"Pacote ARP enviado\")\n+        #self.logger.info(\"\\npacket-in %s\" % (pkt,))\n \n-        \n-    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n-    def _packet_in_handler(self, ev):\n-        print(\"new Packet\")\n-        print(\"current mac table:\")\n-        print(self.mac_to_port)\n-        # If you hit this you might want to increase\n-        # the \"miss_send_length\" of your switch\n-        if ev.msg.msg_len < ev.msg.total_len:\n-            self.logger.debug(\"packet truncated: only %s of %s bytes\",\n-                              ev.msg.msg_len, ev.msg.total_len)\n-        msg = ev.msg\n-        datapath = msg.datapath\n+        pkt_ethernet = pkt.get_protocol(ethernet.ethernet)\n+        if not pkt_ethernet:\n+            return\n+        pkt_arp = pkt.get_protocol(arp.arp)\n+        if pkt_arp:\n+            #ARP handling\n+            self.handle_arp(msg, port, pkt_ethernet, pkt_arp)\n+            return\n+        pkt_ipv4 = pkt.get_protocol(ipv4.ipv4)\n+        if pkt_ipv4:\n+            if pkt_ipv4.dst in self.router_ports_to_ip.values():\n+                pkt_icmp = pkt.get_protocol(icmp.icmp)\n+                if pkt_icmp:\n+                    self.handle_icmp(msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp)\n+                    return\n+            else:\n+                #Static routing handling\n+                if pkt_ipv4.dst in self.ip_to_port.keys():\n+                    self.logger.info(\"\\nPacket received by router %s from %s to %s \", dpid, pkt_ipv4.src, pkt_ipv4.dst)\n+                    self.ip_to_mac.setdefault(dpid, {})\n+                    if pkt_ipv4.dst in self.ip_to_mac[dpid].keys():\n+                        out_port = self.ip_to_port[pkt_ipv4.dst]\n+                        pkt_ethernet.src = self.router_ports[dpid][out_port]\n+                        pkt_ethernet.dst = self.ip_to_mac[dpid][pkt_ipv4.dst]\n+                        self.send_packet(msg.datapath,out_port,pkt)\n+                        return\n+\n+                    else:\n+                        #Send ARP Request\n+                        self.packet_queue.setdefault(pkt_ipv4.dst,[])\n+                        self.packet_queue[pkt_ipv4.dst].append(msg)\n+                        self.logger.info(\"\\nRouter %s doesn't know MAC of %s adding packet to queue\", dpid, pkt_ipv4.dst)\n+                        self.send_arp_request(msg, pkt_ipv4)\n+                        return\n+\n+                else:\n+                    self.logger.info(\"\\nPacket received by router %s from %s to %s (unknown destination)\", dpid, pkt_ipv4.src, pkt_ipv4.dst)\n+                    self.send_icmp_unreachable(msg, port, pkt_ethernet, pkt_ipv4)\n+                    #Send ICMP network unreachable\n+                   \n+\n+\n+    def send_arp_request(self, msg, pkt_ipv4):\n+        out_port = self.ip_to_port[pkt_ipv4.dst]\n+        src_mac = self.router_ports[msg.datapath.id][out_port]\n+        src_ip = self.router_ports_to_ip[out_port]\n+\n+\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\n+                                           dst='ff:ff:ff:ff:ff:ff',\n+                                           src=src_mac))\n+        pkt.add_protocol(arp.arp(opcode=arp.ARP_REQUEST,\n+                                 src_mac=src_mac,\n+                                 src_ip=src_ip,\n+                                 dst_mac='ff:ff:ff:ff:ff:ff',\n+                                 dst_ip=pkt_ipv4.dst))\n+\n+        self.send_packet(msg.datapath,out_port,pkt)\n+\n+        self.logger.info(\"\\nRouter %s sending ARP Request from port %s to learn MAC of %s\", msg.datapath.id, out_port, pkt_ipv4.dst)\n+\n+\n+    def send_packet(self, datapath, port, pkt):\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n-        in_port = msg.match['in_port']\n+        pkt.serialize()\n+        data = pkt.data\n+        actions = [parser.OFPActionOutput(port=port)]\n+        out = parser.OFPPacketOut(datapath=datapath,\n+                                  buffer_id=ofproto.OFP_NO_BUFFER,\n+                                  in_port=ofproto.OFPP_CONTROLLER,\n+                                  actions=actions,\n+                                  data=data)\n+        datapath.send_msg(out)\n \n-        pkt = packet.Packet(msg.data)\n-        eth = pkt.get_protocols(ethernet.ethernet)[0]\n \n-        if eth.ethertype == ether_types.ETH_TYPE_LLDP:\n-            # ignore lldp packet\n-            return\n-        dst = eth.dst\n-        src = eth.src\n+    def handle_arp(self, msg, port, pkt_ethernet, pkt_arp):\n+        #ARP packet handling.\n+        dpid = msg.datapath.id\n \n-        dpid = datapath.id\n-        self.mac_to_port.setdefault(dpid, {})\n+        if pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REQUEST:\n \n-        self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n+            self.logger.info(\"\\nARP Request received by router %s from %s in port %s \", dpid, pkt_arp.src_ip, port)\n \n-        # learn a mac address to avoid FLOOD next time.\n-        self.mac_to_port[dpid][src] = in_port\n+            port_mac = self.router_ports[dpid][port]\n \n-        if dst in self.mac_to_port[dpid]:\n-            out_port = self.mac_to_port[dpid][dst]\n+            pkt = packet.Packet()\n+            pkt.add_protocol(ethernet.ethernet(ethertype=ether.ETH_TYPE_ARP,\n+                                           dst=pkt_ethernet.src,\n+                                           src=port_mac))\n+            pkt.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n+                                 src_mac=port_mac,\n+                                 src_ip=pkt_arp.dst_ip,\n+                                 dst_mac=pkt_arp.src_mac,\n+                                 dst_ip=pkt_arp.src_ip))\n+            self.send_packet(msg.datapath, port, pkt)\n+\n+            self.logger.info(\"ARP Reply sent by router %s from port %s with MAC %s to %s\", dpid, port, port_mac, pkt_arp.src_ip)\n+\n+            return\n+        elif pkt_arp.dst_ip in self.router_ports_to_ip.values() and pkt_arp.opcode == arp.ARP_REPLY:\n+            self.logger.info(\"\\nARP Reply received by router %s from %s with MAC %s\", dpid, pkt_arp.src_ip, pkt_arp.src_mac)\n+            self.ip_to_mac.setdefault(dpid, {})\n+            self.ip_to_mac[dpid][pkt_arp.src_ip] = pkt_arp.src_mac\n+\n+            for m in self.packet_queue[pkt_arp.src_ip]:\n+                dpid = m.datapath.id        \n+                pkt = packet.Packet(m.data)\n+                pkt_eth = pkt.get_protocol(ethernet.ethernet)\n+                pkt_v4 = pkt.get_protocol(ipv4.ipv4)\n+                out_port = self.ip_to_port[pkt_arp.src_ip]\n+                pkt_eth.src = self.router_ports[dpid][out_port]\n+                pkt_eth.dst = self.ip_to_mac[dpid][pkt_arp.src_ip]\n+                self.send_packet(msg.datapath,out_port,pkt)\n+                self.logger.info(\"Router %s sent queued packet from %s to %s\", dpid, pkt_v4.src, pkt_v4.dst)\n+\n+  \n+            #cycle through all packets to this ip and forward them\n+            return\n         else:\n-            out_port = ofproto.OFPP_FLOOD\n+            self.logger.info(\"\\nARP Packet dropped router %s, %s not an interface ip\", dpid, pkt_arp.dst_ip)\n+            \n+            #Any other case pass\n+            return\n \n-        actions = [parser.OFPActionOutput(out_port)]\n \n-        # install a flow to avoid packet_in next time\n-        if out_port != ofproto.OFPP_FLOOD:\n+    def handle_icmp(self, msg, port, pkt_ethernet, pkt_ipv4, pkt_icmp):\n+        # Send ICMP echo reply.\n \n-            # check IP Protocol and create a match for IP\n-            if eth.ethertype == ether_types.ETH_TYPE_IP:\n-                ip = pkt.get_protocol(ipv4.ipv4)\n-                srcip = ip.src\n-                dstip = ip.dst\n-                protocol = ip.proto\n-                #print srcip dstip protocol\n-                print(\"IP:\", srcip, dstip, protocol)\n-                \n-                 \n-                # verify if we have a valid buffer_id, if yes avoid to send both\n-                # flow_mod & packet_out\n-               \n-               \n-               #IF ICMP\n-                if protocol == in_proto.IPPROTO_ICMP:\n-                   print(\"Pacote ICMP detectado!\")\n-                   match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP,ipv4_src=srcip,ipv4_dst=dstip,ip_proto=protocol)\n+        dpid = msg.datapath.id\n+        src_ip = pkt_ipv4.src\n+        self.logger.info('\\nICMP echo request received by router %s port %s from %s to %s.', dpid, port, src_ip, pkt_ipv4.dst)\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\n+                                           dst=pkt_ethernet.src,\n+                                           src=self.router_ports[dpid][port]))\n+        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\n+                                   src=self.router_ports_to_ip[port],\n+                                   proto=pkt_ipv4.proto))\n+        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,\n+                                   code=icmp.ICMP_ECHO_REPLY_CODE,\n+                                   csum=0,\n+                                   data=pkt_icmp.data))\n+        self.send_packet(msg.datapath, port, pkt)\n+        self.logger.info('Send ICMP echo reply to [%s].', src_ip)\n \n-                if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n-                    self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n-                    return\n-                else:\n-                    self.add_flow(datapath,1,match,actions)\n-               \n-        data = None\n-        if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n-            data = msg.data\n \n-        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,\n-                                  in_port=in_port, actions=actions, data=data)\n-        datapath.send_msg(out)\n+    def send_icmp_unreachable(self, msg, port, pkt_ethernet, pkt_ipv4):\n+        port_mac = self.router_ports[msg.datapath.id][port]\n+\n+        offset = ethernet.ethernet._MIN_LEN\n+        end_of_data = offset + len(pkt_ipv4) + 128\n+        ip_datagram = bytearray()\n+        ip_datagram += msg.data[offset:end_of_data]\n+        data_len = int(len(ip_datagram) / 4)\n+        length_modulus = int(len(ip_datagram) % 4)\n+        if length_modulus:\n+            data_len += 1\n+            ip_datagram += bytearray([0] * (4 - length_modulus))\n+\n+        icmp_data = icmp.dest_unreach(data_len=data_len, data=ip_datagram)\n+\n+        pkt = packet.Packet()\n+        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,\n+                                            dst=pkt_ethernet.src,\n+                                            src=port_mac))\n+        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,\n+                                    src=self.router_ports_to_ip[port],\n+                                    proto=pkt_ipv4.proto))\n+        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_DEST_UNREACH,\n+                                    code=icmp.ICMP_HOST_UNREACH_CODE,\n+                                    csum=0,\n+                                    data=icmp_data))\n+        self.send_packet(msg.datapath, port, pkt)\n+\n+        self.logger.info(\"Router %s sending ICMP Destination Unreachable to %s\", msg.datapath.id, pkt_ipv4.src)\n+\n"
                },
                {
                    "date": 1652290323219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,16 +58,16 @@\n \n         self.add_flow(datapath, 1, match, actions)\n         self.port_desc(datapath)\n \n-\n+    #Função para obter a descrição de portas do switch\n     def port_desc(self, datapath):\n         ofparser = datapath.ofproto_parser\n \n         req = ofparser.OFPPortDescStatsRequest(datapath,0)\n         datapath.send_msg(req)\n \n-\n+    #Função para obter a descrição de portas do switch\n     @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\n     def port_desc_stats_reply_handle(self,ev):\n \n         dpid = ev.msg.datapath.id\n"
                },
                {
                    "date": 1652290786360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,8 +29,16 @@\n \n class SwitchL3(app_manager.RyuApp):\n     OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n \n+    \"\"\"Contrutor para a classe com as seguintes tabelas:\n+        - ip_to_mac: dicionario de ip para mac\n+        - ip_to_port: dicionario de ip para porta (L3)\n+        - router_ports: dicionario de porta para ip \n+        - router_ports_to_ip: dicionario de porta para ip, atribuindo o default route\n+        - packet_queue: dicionario fila de pacotes arp\n+    \"\"\"\n+\n     def __init__(self, *args, **kwargs):\n         super(SwitchL3, self).__init__(*args, **kwargs)\n         self.ip_to_mac = {}\n         self.ip_to_port = {'10.0.1.2' : 1, '10.0.1.3' : 1, '10.0.1.4' : 1,\n@@ -41,8 +49,11 @@\n         \n         self.packet_queue = {}\n \n \n+    \"\"\"\n+    Função responsável pelo evento correspondente ao ennvio das funcionaliades presentes no switch para o controlado\n+    \"\"\"\n     @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n     def switch_features_handler(self, ev):\n         datapath = ev.msg.datapath\n         ofproto = datapath.ofproto\n@@ -58,16 +69,16 @@\n \n         self.add_flow(datapath, 1, match, actions)\n         self.port_desc(datapath)\n \n-    #Função para obter a descrição de portas do switch\n+    #Utility Function\n     def port_desc(self, datapath):\n         ofparser = datapath.ofproto_parser\n \n         req = ofparser.OFPPortDescStatsRequest(datapath,0)\n         datapath.send_msg(req)\n \n-    #Função para obter a descrição de portas do switch\n+    #Utility Function\n     @set_ev_cls(ofp_event.EventOFPPortDescStatsReply, MAIN_DISPATCHER)\n     def port_desc_stats_reply_handle(self,ev):\n \n         dpid = ev.msg.datapath.id\n@@ -80,8 +91,9 @@\n             print(f\"Port {p} has MAC {self.router_ports[dpid][p]}\")\n \n         print(\"\\n\")\n \n+    #Adcionar flows\n     def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n         ofproto = datapath.ofproto\n         parser = datapath.ofproto_parser\n \n"
                }
            ],
            "date": 1652275889062,
            "name": "Commit-0",
            "content": "from ryu.base import app_manager\nfrom ryu.controller import ofp_event\nfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER\nfrom ryu.controller.handler import set_ev_cls\nfrom ryu.ofproto import ofproto_v1_3\nfrom ryu.lib.packet import packet\nfrom ryu.lib.packet import ethernet\nfrom ryu.lib.packet import ether_types\nfrom ryu.lib.packet import ipv4\nfrom ryu.lib.packet import in_proto\nfrom ryu.lib.packet import icmp\nfrom ryu.lib.packet import arp\n\n\n\nclass L3Switch(app_manager.RyuApp):\n    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]\n\n\n    def __init__(self, *args, **kwargs):\n        super(L3Switch, self).__init__(*args, **kwargs)\n        self.mac_to_port = {}\n        self.arp_table = {}\n\n    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)\n    def switch_features_handler(self, ev):\n        datapath = ev.msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        match = parser.OFPMatch()\n        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,\n                                          ofproto.OFPCML_NO_BUFFER)]\n        self.add_flow(datapath, 0, match, actions)\n\n    def add_flow(self, datapath, priority, match, actions, buffer_id=None):\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n\n        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,\n                                             actions)]\n        \n        if parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IPV6):\n            mod = parser.OFPFlowMod(datapath=datapath, priority=0, match=match,instructions=[])\n        \n        if buffer_id:\n            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,\n                                    idle_timeout=500, hard_timeout=500, priority=priority, match=match,\n                                    instructions=inst)\n        else:\n            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,\n                                    idle_timeout=500, hard_timeout=500, match=match, instructions=inst)\n        datapath.send_msg(mod)\n        \n\n    \n    def arp_process(self, datapath, eth, a, in_port):\n        r = self.arp_table.get(a.dst_ip)\n        if r:\n            self.logger.info(\"Matched MAC %s \", r)\n            arp_resp = packet.Packet()\n            arp_resp.add_protocol(ethernet.ethernet(ethertype=eth.ethertype,\n                                    dst=eth.src, src=r))\n            arp_resp.add_protocol(arp.arp(opcode=arp.ARP_REPLY,\n                                    src_mac=r, src_ip=a.dst_ip,\n                                    dst_mac=a.src_mac,\n                                    dst_ip=a.src_ip))\n\n            arp_resp.serialize()\n            actions = []\n            actions.append(datapath.ofproto_parser.OFPActionOutput(in_port))\n            parser = datapath.ofproto_parser  \n            ofproto = datapath.ofproto\n            out = parser.OFPPacketOut(datapath=datapath, buffer_id=ofproto.OFP_NO_BUFFER,\n                                    in_port=ofproto.OFPP_CONTROLLER, actions=actions, data=arp_resp)\n            datapath.send_msg(out)\n            self.logger.info(\"Enviado ARP Response packet para %s\", r)\n        else: \n            print(\"Endereço não encontrado\")\n    \n    \n    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)\n    def _packet_in_handler(self, ev):\n        # If you hit this you might want to increase\n        # the \"miss_send_length\" of your switch\n        if ev.msg.msg_len < ev.msg.total_len:\n            self.logger.debug(\"packet truncated: only %s of %s bytes\",\n                              ev.msg.msg_len, ev.msg.total_len)\n        msg = ev.msg\n        datapath = msg.datapath\n        ofproto = datapath.ofproto\n        parser = datapath.ofproto_parser\n        in_port = msg.match['in_port']\n\n        pkt = packet.Packet(msg.data)\n        eth = pkt.get_protocols(ethernet.ethernet)[0]\n\n        if eth.ethertype == ether_types.ETH_TYPE_LLDP:\n            # ignore lldp packet\n            return\n        dst = eth.dst\n        src = eth.src\n\n        dpid = datapath.id\n        self.mac_to_port.setdefault(dpid, {})\n\n        self.logger.info(\"packet in %s %s %s %s\", dpid, src, dst, in_port)\n\n        # learn a mac address to avoid FLOOD next time.\n        self.mac_to_port[dpid][src] = in_port\n        \n        #check if arp packet is received\n        if eth.ethertype == ether_types.ETH_TYPE_ARP:\n            self.logger.info(\"Pacote ARP recebido %s %s %s\", dpid, src, dst)\n            a = pkt.get_protocol(arp.arp)\n            self.arp_process(datapath, eth, a, in_port)\n            return\n\n        if dst in self.mac_to_port[dpid]:\n            out_port = self.mac_to_port[dpid][dst]\n        else:\n            out_port = ofproto.OFPP_FLOOD\n\n        actions = [parser.OFPActionOutput(out_port)]\n\n        # install a flow to avoid packet_in next time\n        if out_port != ofproto.OFPP_FLOOD:\n\n            if eth.ethertype == ether_types.ETH_TYPE_IP:\n                ip = pkt.get_protocol(ipv4.ipv4)\n                srcip = ip.src\n                dstip = ip.dst\n                protocol = ip.proto\n                \n                if protocol == in_proto.IPPROTO_ICMP:\n                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, ipv4_src=srcip, ipv4_dst=dstip)\n                if msg.buffer_id != ofproto.OFP_NO_BUFFER:\n                    self.add_flow(datapath, 1, match, actions, msg.buffer_id)\n                    return\n                else:\n                    self.add_flow(datapath, 1, match, actions)\n        data = None\n        if msg.buffer_id == ofproto.OFP_NO_BUFFER:\n            data = msg.data\n\n        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,\n                                  in_port=in_port, actions=actions, data=data)\n        datapath.send_msg(out)\n\n"
        }
    ]
}